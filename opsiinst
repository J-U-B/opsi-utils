#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = =
   =   opsiinst    =
   = = = = = = = = =
   
   opsi-package-manager is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '0.5.7'

import os, stat, getopt, gettext, popen2, select, time, socket

# OPSI imports
from OPSI.Logger import *
from OPSI.System import *
from OPSI.Product import *
from OPSI.UI import *

# Globals
TMP_DIR = '/tmp'

ui = None

# Get logger instance
logger = Logger()

# Get locale
try:
	t = gettext.translation('opsi_opsiinst', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string

def usage():
	print _("\nUsage: %s [options] <opsi package>") % os.path.basename(sys.argv[0])
	print _("Install an opsi package.")
	print _("Options:")
	print _("    -v                show version information")
	print _("    -x                extract package source")
	print _("    -h                this help text")
	print _("    -q                quiet, don't ask any questions")
	print _("    -f                force installation")
	print _("    -k                keep default properties of installed product (default)")
	print _("    -n                use default properties of product package")
	print _("    -d                enable debug mode")
	print _("    -l <log-file>     use a file for logging")
	print _("    -i <interface>    user interface [snack|text]")
	print _("    -t                temp dir")
	print ""


def main(argv):
	os.umask(0027)
	
	uiType = None
	debug = False
	quiet = False
	force = False
	createSource = False
	sourceDir = None
	tempDir = '/tmp'
	oldDefaults = []
	keepOldDefaults = True
	
	print _("!!! opsiinst is deprecated, please use opsi-package-manager !!!")
	
	try:
		(opts, args) = getopt.getopt(argv, "vxhqknfdl:i:t:")
	
	except getopt.GetoptError:
		usage()
		sys.exit(1)
	
	for (opt, arg) in opts:
		if   (opt == "-h"):
			usage()
			return
		elif (opt == "-v"):
			print __version__
			return
		elif (opt == "-d"):
			debug = True
		elif (opt == "-q"):
			quiet = True
		elif (opt == "-f"):
			force = True
		elif (opt == "-n"):
			keepOldDefaults = False
		elif (opt == "-k"):
			keepOldDefaults = True
		elif (opt == "-l"):
			arg = os.path.abspath(arg)
			if os.path.exists(arg):
				os.unlink(arg)
			logger.setLogFile(arg)
			logger.setFileLevel(LOG_DEBUG)
		elif (opt == "-i"):
			uiType = arg
		elif (opt == "-x"):
			createSource = True
		elif (opt == "-t"):
			tempDir = arg
	
	if quiet:
		debug = False
		uiType = 'dummy'
	
	if debug:
		uiType = 'text'
		logger.setConsoleColor(True)
		logger.setConsoleLevel(LOG_DEBUG)
	
	if (len(args) < 1):
		print >> sys.stderr, _("No opsi package given!")
		usage()
		sys.exit(1)
	elif (len(args) > 1):
		usage()
		sys.exit(1)
	
	if createSource:
		if not sourceDir:
			sourceDir = os.path.abspath(os.getcwd())
	
	packageFile = os.path.abspath(args[0])
	if not os.path.exists(packageFile):
		print >> sys.stderr, _("Package file '%s' does not exist!") % packageFile
		sys.exit(1)
	
	if packageFile.endswith('cpio.gz'):
		print _("Opsi legacy package, invoking command opsiinstv2 ...")
		try:
			os.chdir('/')
			argv.insert(0, "opsiinstv2")
			os.execvp("opsiinstv2", argv)
		except Exception, e:
			print >> sys.stderr, _("Failed to execute command '%s': %s") \
				% (' '.join(argv), e)
			sys.exit(1)
		
	global ui
	ui = UIFactory(uiType)
	
	ui.drawRootText(1, 1, _('Open PC ServerIntegration'))
	setUI(ui)
	
	from OPSI.Backend.BackendManager import BackendManager
	bm = BackendManager(authRequired=False)
	
	ui.drawRootText(3, 3, _("Opening package file '%s' ...") % packageFile)
	
	ppf = ProductPackageFile(packageFile, tempDir = tempDir)
	
	ppf.setClientDataDir(os.path.join('/opt/pcbin/install', ppf.product.productId))
	
	ui.showMessage(_("opsiinst is deprecated, please use opsi-package-manager instead"), title=_('opsiinst deprecated'), seconds=3)
	
	try:
		if sourceDir:
			mbox = ui.createMessageBox(title=_('Creating package source of %s' % ppf.product.productId))
		else:
			mbox = ui.createMessageBox(title=_('Installation of %s' % ppf.product.productId))
		
		mbox.addText( _("productType:       %s\n") % ppf.product.productType )
		mbox.addText( _("customName:        %s\n") % ppf.customName )
		mbox.addText( _("name:              %s\n") % ppf.product.name )
		mbox.addText( _("productVersion:    %s\n") % ppf.product.productVersion )
		mbox.addText( _("packageVersion:    %s\n") % ppf.product.packageVersion )
		mbox.addText( _("licenseRequired:   %s\n") % ppf.product.licenseRequired )
		mbox.addText( _("setupScript:       %s\n") % ppf.product.setupScript )
		mbox.addText( _("uninstallScript:   %s\n") % ppf.product.uninstallScript )
		mbox.addText( _("updateScript:      %s\n") % ppf.product.updateScript )
		mbox.addText( _("alwaysScript:      %s\n") % ppf.product.alwaysScript )
		mbox.addText( _("onceScript:        %s\n") % ppf.product.onceScript )
		mbox.addText( _("priority:          %s\n") % ppf.product.priority )
		mbox.addText( _("description:       %s\n") % ppf.product.description )
		mbox.addText( _("advice:            %s\n") % ppf.product.advice )
		mbox.addText( _("productClassNames: %s\n") % ppf.product.productClassNames )
		if (ppf.product.productType == 'netboot'):
			mbox.addText( _("pxeConfigTemplate: %s\n") % ppf.product.pxeConfigTemplate )
		mbox.addText("\n")
		
		if sourceDir:
			mbox.addText( _("Unpacking source...\n") )
			ppf.unpackSource(sourceDir)
			ui.exit()
			return
		
		mbox.addText( _("Checking package dependencies...\n") )
		ppf.checkDependencies()
		
		mbox.addText( _("Locking product...\n") )
		ppf.lock()
		
		exists = False
		for productId in bm.getProductIds_list():
			if (productId == ppf.product.productId):
				exists = True
				break
		
		if exists:
			if quiet:
				if not force:
					raise Exception(_("Product '%s' already exists in the database!") % productId)
			
			else:
				if not force and not ui.yesno(
					title	= _("Overwrite?"), 
					text	= _("Product '%s' already exists in the database do you want to replace it?") % productId ):
						raise Exception(_('Canceled'))
		
		mbox.addText( _("Running preinst...\n") )
		
		preinst = ppf.runPreinst(getHandle = True)
		if preinst:
			text = posix.read(preinst.fileno(), 128)
			while text:
				mbox.addText(text)
				text = posix.read(preinst.fileno(), 128)
				logger.debug(text)
			
		if exists:
			# Get old default values
			oldDefaults = bm.getProductPropertyDefinitions_listOfHashes(productId)
			# Delete all product dependencies
			bm.deleteProductDependency(ppf.product.productId)
			# Delete productPropertyDefinitions
			bm.deleteProductPropertyDefinitions(ppf.product.productId)
			# Not deleting product, because this would delete client productstates as well
		
		if ppf.incremental:
			mbox.addText( _("Incremental package, not deleting old client files...\n") )
		else:
			mbox.addText( _("Deleting old client files...\n") )
			ppf.deleteClientDataDir()
		
		mbox.addText( _("Unpacking files...\n") )
		
		ppf.unpack()
		
		mbox.addText( _("Setting access rights...\n") )
		ppf.setAccessRights()
		
		mbox.addText( _("Registering product...\n") )
		bm.createProduct(
				ppf.product.productType,
				ppf.product.productId,
				ppf.product.name,
				ppf.product.productVersion,
				ppf.product.packageVersion,
				ppf.product.licenseRequired,
				ppf.product.setupScript,
				ppf.product.uninstallScript,
				ppf.product.updateScript,
				ppf.product.alwaysScript,
				ppf.product.onceScript,
				ppf.product.priority,
				ppf.product.description,
				ppf.product.advice,
				ppf.product.productClassNames,
				ppf.product.pxeConfigTemplate
			)
		
		if (ppf.product.productType != 'server'):
			for d in ppf.product.productDependencies:
				bm.createProductDependency(
					d.productId,
					d.action,
					d.requiredProductId,
					d.requiredProductClassId,
					d.requiredAction,
					d.requiredInstallationStatus,
					d.requirementType,
				)
		
			properties = {}
			for p in ppf.product.productProperties:
				defaultValue = p.defaultValue
				if keepOldDefaults:
					for old in oldDefaults:
						if (old['name'] == p.name):
							if not p.possibleValues or old['default'] in p.possibleValues:
								defaultValue = old['default']
							break
				if not quiet:
					if (len(p.possibleValues) > 0):
						values = []
						for v in p.possibleValues:
							values.append( { "name": v, "selected": (v == defaultValue) } )
						defaultValue = ui.getSelection(values, radio=True,
										title=_("Please select default value for product property '%s'") % p.name, 
										text=p.description)
						if defaultValue != None:
							defaultValue = defaultValue[0]
					else:
						defaultValue = ui.getValue(text=p.description, default=defaultValue)
					
					if (defaultValue != None):
						p.defaultValue = defaultValue
				
				bm.createProductPropertyDefinition(
					p.productId,
					p.name,
					p.description,
					defaultValue,
					p.possibleValues
				)
				properties[p.name] = defaultValue
			
			if properties:
				bm.setProductProperties(p.productId, properties)
			
			name = socket.getfqdn()
			mbox.addText( _("Setting product-installation-status on server '%s' to installed...\n") % name )
			bm.setProductInstallationStatus(ppf.product.productId, name, 'installed')
		
		mbox.addText( _("Running postinst...\n") )
		
		postinstResult = ''
		postinst = ppf.runPostinst(getHandle = True)
		if postinst:
			text = posix.read(postinst.fileno(), 128)
			while text:
				#logger.debug(text)
				postinstResult += text
				mbox.addText(text)
				text = posix.read(postinst.fileno(), 128)
		
		mbox.addText( _("Unlocking product...\n") )
		
		# Set to setup where installed
		if not quiet and (ppf.product.productType != 'server'):
			clientIds = bm.getClientIds_list(productId = ppf.product.productId, installationStatus = 'installed')
			if clientIds:
				clientIds.sort()
				if ui.yesno(
					title	= _("Set action to 'setup' where installation status 'installed'?"), 
					text	= _("Set action 'setup' for product '%s' on clients:\n%s") \
							% (ppf.product.productId, '\n'.join(clientIds)) ):
						for clientId in clientIds:
							bm.setProductActionRequest(productId, clientId, 'setup')
			
			
		mbox.addText( _("Cleaning up...\n") )
		
		if (str(ui.__class__) != 'OPSI.UI.TextUI'):
			time.sleep(3)
			ui.exit()
			if not quiet and postinstResult:
				print postinstResult
		
		else:
			ui.exit()
	except Exception:
		ppf.cleanup()
		ppf.unlock()
		raise
	ppf.cleanup()
	ppf.unlock()
	
	
	

if (__name__ == "__main__"):
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if ui: 
		try:
			ui.exit()
		except:
			pass
	
	if exception:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(exception)
		print >> sys.stderr, _("Installation failed:"), str(exception)
		sys.exit(1)
	
	sys.exit(0)



