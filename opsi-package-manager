#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = =
   =   opsi-package-manager    =
   = = = = = = = = = = = = = = =
   
   opsi-package-manager is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2010 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '3.4.99'


# Imports
import os, sys, threading, time, termios, socket, random, base64
from signal import *
from optparse import OptionParser
from duplicity import librsync

# OPSI Imports
from OPSI.Logger import *
from OPSI.Types import *
from OPSI.Util import md5sum
from OPSI.Util.Message import MessageSubject, ProgressSubject
from OPSI.Util.Repository import *
from OPSI.Util.Product import ProductPackageFile
from OPSI.Backend.BackendManager import BackendManager
from OPSI.Backend.JSONRPC import JSONRPCBackend

# Get logger instance
logger = Logger()


def _(string):
	return string

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                               TASK                                                -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class Task:
	def __init__(self, name, opsiPackageManager, method, params):
		self.name = forceUnicode(name)
		self.opsiPackageManager = opsiPackageManager
		self.method = method
		self.params = forceList(params)
		self.started = False
		self.ended = False
		self.exception = None
	
	def abort(self):
		pass
	
	def isRunning(self):
		return self.started and not self.ended
		
	def start(self):
		logger.debug(u"Task start()")
		self.started = True
		try:
			logger.debug2(u"Method: %s" % self.method)
			logger.debug2(u"Params: %s" % self.params)
			self.method( *self.params )
		except Exception, e:
			logger.logException(e)
			self.exception = e
			self.ended = True
			raise
		self.ended = True
	
class UploadTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)
	
	def start(self):
		while self.opsiPackageManager.maxTransfersReached():
			logger.debug(u"Maximum number transfers reached, waiting")
			time.sleep(1)
		Task.start(self)
		
class InstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class UninstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)
		
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                             TASKQUEUE                                             -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class TaskQueue(threading.Thread):
	def __init__(self, name):
		threading.Thread.__init__(self)
		self.name = forceUnicode(name)
		self.tasks = []
		self.started = False
		self.ended = False
		self.errors = []
		self.currentTaskNumber = -1
	
	def abort(self):
		self.ended = True
		task = self.getCurrentTask()
		if task:
			task.abort()
		
	def getCurrentTask(self):
		if (self.currentTaskNumber < 0):
			return None
		return self.tasks[self.currentTaskNumber]
	
	def run(self):
		self.currentTaskNumber = -1
		if not self.tasks:
			raise Exception(u"No tasks in queue")
		self.started = True
		logger.debug(u"TaskQueue '%s' started" % self.name)
		i = 0
		while (i < len(self.tasks)):
			if self.ended:	return
			task = self.tasks[i]
			try:
				logger.debug(u"Starting task '%s'" % task.name)
				self.currentTaskNumber += 1
				task.start()
				logger.debug(u"Task '%s' ended" % task.name)
				if (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], UploadTask):
					# Sleeping 3 seconds to provide the opportunity to start other upload tasks
					time.sleep(3)
			except Exception, e:
				logger.error(u"Task '%s' failed: %s" % (task.name, e))
				self.errors.append(e)
				if (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], InstallTask):
					# Upload task failed => do not execute install task
					logger.notice(u"Upload task failed, skipping install task")
					i += 1
			i += 1
		self.ended = True
	
	def addTask(self, task):
		if not isinstance(task, Task):
			raise ValueError(u"Task wanted, '%s' passed" % task)
		self.tasks.append(task)
	
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                         OPSIPACKAGEMANAGER                                        -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class OpsiPackageManager():
	
	def __init__(self, config, backend):
		self.config = config
		self.backend = backend
		
		self.aborted = False
		self.userInterface = None
		self.taskQueues = []
		self.productPackageFiles = {}
		self.runningTransfers = 0
		
		self.infoSubject = MessageSubject(u'info')
		self.transferSubject = MessageSubject(u'transfers')
		self.depotSubjects = {}
		
		
		self.productPackageFilesLock = threading.Lock()
		self.runningTransfersLock = threading.Lock()
		
		self.infoSubject.setMessage(u'opsi-package-manager')
		
		logger.info(u"OpsiPackageManager initiated")
		
	def abort(self):
		self.aborted = True
		running = True
		while running:
			running = False
			for tq in self.taskQueues:
				if not tq.ended:
					logger.notice(u"Aborting task queue '%s'" % tq.name)
					tq.abort()
	
	def getDepotConnection(self, depotId):
		depot = self.backend.host_getObjects(type = 'OpsiDepotserver', id = depotId)[0]
		return JSONRPCBackend( username = depotId, password = depot.getOpsiHostKey(), address = depotId )
	
	def getRunningTransfers(self):
		return self.runningTransfers
	
	def setRunningTransfers(self, num):
		self.runningTransfersLock.acquire()
		self.runningTransfers = num
		self.runningTransfersLock.release()
		if self.config['maxTransfers']:
			self.transferSubject.setMessage( _("%d/%d transfers running") \
				% (self.runningTransfers, self.config['maxTransfers']) )
		else:
			self.transferSubject.setMessage( _("%d transfers running") \
				% self.runningTransfers )
		
	def maxTransfersReached(self):
		if self.config['maxTransfers'] and (self.getNumberOfTransfers() >= self.config['maxTransfers']):
			return True
		return False
	
	def createDepotSubjects(self, depotIds):
		if self.depotSubjects and self.userInterface:
			for subject in self.depotSubjects.values():
				self.userInterface.removeSubject(subject)
		for depotId in depotIds:
			self.depotSubjects[depotId] = MessageSubject(id = depotId, type = u'depot')
			if self.userInterface:
				self.userInterface.addSubject(self.depotSubjects[depotId])
	
	def getDepotSubject(self, depotId):
		return self.depotSubjects.get(depotId)
	
	def openProductPackageFile(self, packageFile):
		self.infoSubject.setMessage( _(u'Opening package file %s' % os.path.basename(packageFile)) )
		self.productPackageFilesLock.acquire()
		try:
			if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
				self.productPackageFiles[os.path.basename(packageFile)] = ProductPackageFile(packageFile)
				self.productPackageFiles[os.path.basename(packageFile)].getMetaData()
		finally:
			self.productPackageFilesLock.release()
	
	def getPackageControlFile(self, packageFile):
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.openProductPackageFile(packageFile)
		return self.productPackageFiles[os.path.basename(packageFile)].packageControlFile
		
	def waitForTaskQueues(self):
		self.infoSubject.setMessage( _(u'Waiting for task queues to finish up') )
		running = 1
		while running:
			running = 0
			for tq in self.taskQueues:
				if not tq.ended:
					logger.debug(u"Task queue %s running, waiting" % tq.name)
					running +=1
			self.infoSubject.setMessage( _(u'%d/%d task queues running') \
								% (running, len(self.taskQueues)) )
			time.sleep(1)
	
	def uploadToRepositories(self):
		self.createDepotSubjects(self.config['depotIds'])
		
		for packageFile in self.config['packageFiles']:
			self.openProductPackageFile(packageFile)
		
		for depotId in self.config['depotIds']:
			tq = TaskQueue(name = u"Upload of package(s) %s to repository '%s'" % (', '.join(self.config['packageFiles']), depotId))
			for packageFile in self.config['packageFiles']:
				tq.addTask(
					UploadTask(
						name = u"Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = [packageFile, depotId]
					)
				)
			if not self.aborted:
				self.taskQueues.append(tq)
				logger.info(u"Starting task queue '%s'" % tq.name)
				tq.start()
		self.waitForTaskQueues()
	
	def uploadToRepository(self, packageFile, depotId):
		subject = self.getDepotSubject(depotId)
		try:
			# Process upload
			logger.notice(u"Processing upload of '%s' to depot '%s'" \
					% (os.path.basename(packageFile), depotId))
			subject.setMessage( _(u"Processing upload of %s") % os.path.basename(packageFile) )
			
			packageSize = os.stat(packageFile)[stat.ST_SIZE]
			lMD5 = md5sum(packageFile)
			destination = os.path.basename(packageFile)
			
			productId = self.getPackageControlFile(packageFile).getProduct().getId()
			
			depot = self.backend.host_getObjects(type = 'OpsiDepotserver', id = depotId)[0]
			logger.info(u"Using '%s' as repository url" % depot.repositoryRemoteUrl)
			
			repository = getRepository(depot.repositoryRemoteUrl, depotId, depot.opsiHostKey)
			if self.config['maxBandwidth']:
				logger.info(u"Setting max bandwith for depot '%s' to %d" % (depotId, self.config['maxBandwidth']))
				repository.setMaxBandwidth(self.config['maxBandwidth'])
			
			for dest in repository.content():
				if (dest['name'] == destination):
					logger.info(u"Destination '%s' already exists on depot '%s'" % (destination, depotId))
					if not self.config['overwriteAlways']:
						# Not overwriting always => checking file sizes first
						if ( repository.fileInfo(destination)['size'] != packageSize ):
							# Size differs => overwrite
							logger.info(u"Size of source and destination differs on depot '%s'" % depotId)
						else:
							# Sizes match => check md5sum
							logger.info(u"Size of source and destination matches on depot '%s'" % depotId)
							depotConnection = self.getDepotConnection(depotId)
							rMD5 = depotConnection.depot_getMD5Sum(depotRepositoryPath + u'/' + os.path.basename(packageFile))
							depotConnection.backend_exit()
							if (lMD5 == rMD5):
								# md5sum match => do not overwrite
								logger.info(u"MD5sum of source and destination matches on depot '%s'" % depotId)
								subject.setMessage( _(u"No need to upload, %s is up to date") % os.path.basename(packageFile), severity = 4 )
								return
							# md5sums differ => overwrite
							logger.info(u"MD5sum of source and destination differs on depot '%s'" % depotId)
							
					logger.info(u"Overwriting destination '%s' on depot '%s'" % (destination, depotId))
					subject.setMessage( _(u"Overwriting destination %s") % destination )
					break
			
			depotConnection = self.getDepotConnection(depotId)
			if not depot.repositoryLocalUrl.startswith('file://'):
				raise Exception(u"Repository local url '%s' not supported" % depot.repositoryLocalUrl)
			depotRepositoryPath = depot.repositoryLocalUrl[7:]
			if depotRepositoryPath.endswith('/'):
				depotRepositoryPath = depotRepositoryPath[:-1]
			info = depotConnection.depot_getDiskSpaceUsage(depotRepositoryPath)
			depotConnection.backend_exit()
			if (info['available'] < packageSize):
				subject.setMessage( _(u"Not enough disk space: %dMB needed, %dMB available") \
							% ( (packageSize/(1024*1024)), (info['available']/(1024*1024)) ) )
				raise Exception(u"Not enough disk space on depot '%s': %dMB needed, %dMB available" \
							% (depotId, (packageSize/(1024*1024)), (info['available']/(1024*1024))))
			
			oldPackages = []
			for dest in repository.content():
				if dest['name'].startswith(productId + '_') and not (dest['name'] == destination):
					# same product, other version
					oldPackages.append(dest['name'])
			newOldPackages = []
			
			if self.maxTransfersReached():
				subject.setMessage( _(u"Waiting for free upload slot for %s") % os.path.basename(packageFile) )
				while self.maxTransfersReached():
					time.sleep(0.1 * random.randint(1, 20))
			self.setRunningTransfers(self.getRunningTransfers() + 1)
			subject.setMessage( _(u"Starting upload") )
			depotConnection = None
			try:
				if self.config['deltaUpload'] and oldPackages:
					depotConnection = None
					deltaFile = None
					try:
						oldPackage = oldPackages[0]
						depotConnection = self.getDepotConnection(depotId)
						
						logger.notice(u"Getting librsync signature of '%s' on depot '%s'" % (oldPackage, depotId))
						subject.setMessage( _(u"Getting librsync signature of %s") % oldPackage )
						
						sig = base64.decodestring( depotConnection.librsyncSignature(depotRepositoryPath + '/' + oldPackage) )
						
						logger.notice(u"Calculating delta for depot '%s'" % depotId)
						subject.setMessage( _(u"Calculating delta") )
						
						deltaFilename = '%s_%s.delta' % (productId, depotId)
						
						if deltaFilename in oldPackages:
							newDeltaFilename = deltaFilename
							i = 0
							while newDeltaFilename in oldPackages:
								newDeltaFilename = deltaFilename + '.' + str(i)
								i += 1
							deltaFilename = newDeltaFilename
						
						deltaFile = os.path.join('/tmp', deltaFilename)
						
						bufsize = 1024*1024
						bf = open(packageFile, "rb")
						df = open(deltaFile, "wb")
						ldf = librsync.DeltaFile(sig, bf)
						
						data = True
						while(data):
							data = ldf.read(bufsize)
							df.write(data)
						df.close()
						bf.close()
						ldf.close()
						
						packageSize = os.stat(packageFile)[stat.ST_SIZE]
						deltaSize = os.stat(deltaFile)[stat.ST_SIZE]
						speedup = (float(packageSize)/float(deltaSize))-1
						if (speedup < 0):
							speedup = 0
						logger.notice(u"Delta calculated, upload speedup is %.3f" % speedup)
						logger.notice(u"Starting delta upload of '%s' to depot '%s'" \
							% (deltaFilename, depotId))
						subject.setMessage( _(u"Starting delta upload of %s") \
									    % os.path.basename(packageFile) )
						
						progressSubject = ProgressSubject(id = depotId, type = 'upload')
						progressSubject.setMessage(u"Uploading %s (delta upload, speedup %.1f%%)" \
									% (os.path.basename(packageFile), speedup*100) )
						if self.userInterface:
							self.userInterface.addSubject(progressSubject)
						
						repository.upload(deltaFile, deltaFilename, progressSubject)
						
						if self.userInterface:
							self.userInterface.removeSubject(progressSubject)
						
						logger.notice(u"Patching '%s'" % oldPackage)
						subject.setMessage( _(u"Patching %s") % oldPackage )
						
						depotConnection.librsyncPatchFile(depotRepositoryPath + u'/' + oldPackage, depotRepositoryPath + u'/' + deltaFilename, depotRepositoryPath + u'/' + destination)
						
						repository.delete(deltaFilename)
					finally:
						if depotConnection:
							depotConnection.backend_exit()
						if deltaFile and os.path.exists(deltaFile):
							os.unlink(deltaFile)
					
				else:
					
					logger.notice(u"Starting upload of '%s' to depot '%s'" 	% (os.path.basename(packageFile), depotId))
					subject.setMessage( _(u"Starting upload of %s") % os.path.basename(packageFile) )
					
					progressSubject = ProgressSubject(id = depotId, type = u'upload')
					progressSubject.setMessage(u"Uploading %s" % os.path.basename(packageFile))
					if self.userInterface:
						self.userInterface.addSubject(progressSubject)
					
					repository.upload(packageFile, destination, progressSubject)
					
					if self.userInterface:
						self.userInterface.removeSubject(progressSubject)
			finally:
				self.setRunningTransfers(self.getRunningTransfers() - 1)
			
			logger.notice(u"Upload of '%s' to depot '%s' finished" % (os.path.basename(packageFile), depotId))
			subject.setMessage( _(u"Upload of %s finished") % os.path.basename(packageFile) )
			
			for oldPackage in oldPackages:
				if (oldPackage == destination):
					continue
				try:
					logger.notice(u"Deleting '%s' from depot '%s'" % (oldPackage, depotId))
					repository.delete(oldPackage)
				except Exception, e:
					logger.error(u"Failed to delete '%s' from depot '%s': %s" % (oldPackage, depotId, e))
			
			logger.notice(u"Verifying upload")
			subject.setMessage( _(u"Verifying upload") )
			
			depotConnection = self.getDepotConnection(depotId)
			rMD5 = depotConnection.depot_getMD5Sum(depotRepositoryPath + u'/' + os.path.basename(packageFile))
			info = depotConnection.depot_getDiskSpaceUsage(depotRepositoryPath)
			depotConnection.backend_exit()
			if (lMD5 != rMD5):
				# md5sum differ
				raise Exception(u"MD5sum of source '%s' and destination '%s' differ after upload to depot '%s'" % (lMD5, rMD5, depotId))
			
			if (info['usage'] >= 0.9):
				logger.warning(u"Warning: %d%% filesystem usage at repository on depot '%s'" % (int(100*info['usage']), depotId))
				subject.setMessage( _(u"Warning: %d%% filesystem usage") % int(100*info['usage']), severity = 3 )
			
			logger.notice(u"Upload of '%s' to depot '%s' successful" % (os.path.basename(packageFile), depotId))
			subject.setMessage( _(u"Upload of %s successful") % os.path.basename(packageFile), severity = 4)
			
		except Exception, e:
			logger.error(e)
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _(u"Upload failed: %s") % e, severity = 2 )
			raise
	
	def uninstallPackages(self):
		productIds = []
		for product in self.backend.product_getObjects(id = self.config['productIds']):
			if not product.id in productIds:
				productIds.append(product.id)
		
		for depotId in self.config['depotIds']:
			tq = TaskQueue(name = u"Uninstall of package(s) %s on depot '%s'" % (', '.join(productIds), depotId))
			for productId in productIds:
				tq.addTask(
					UninstallTask(
						name = u"Uninstall of package '%s' on depot '%s'" % (productId, depotId),
						opsiPackageManager = self,
						method = self.uninstallPackage,
						params = [productId, depotId]
					)
				)
			self.taskQueues.append(tq)
			logger.info(u"Starting task queue '%s'" % tq.name)
			tq.start()
		self.waitForTaskQueues()
		
	def uninstallPackage(self, productId, depotId):
		depotConnection = None
		try:
			logger.notice(u"Uninstalling package '%s' on depot '%s'" % (productId, depotId))
			#if not self.quiet: print u"Uninstalling package '%s' on depot '%s'" \
			#			% (productId, depotId)
			
			depot = self.backend.host_getObjects(type = 'OpsiDepotserver', id = depotId)[0]
			logger.info(u"Using '%s' as repository url" % depot.getRepositoryRemoteUrl())
			repository = getRepository(depot.getRepositoryRemoteUrl(), depotId, depot.getOpsiHostKey())
			for destination in repository.content():
				if not destination['name'].startswith(u'%s_' % productId):
					continue
				logger.info(u"Deleting destination '%s' on depot '%s'" % (destination['name'], depotId))
				repository.delete(destination['name'])
			
			depotConnection = self.getDepotConnection(depotId)
			depotConnection.depot_uninstallPackage(productId, force = self.config['forceUninstall'], deleteFiles = self.config['deleteFilesOnUninstall'])
			logger.notice(u"Uninstall of package '%s' on depot '%s' finished" % (productId, depotId))
			
		except Exception, e:
			logger.error(e)
			if depotConnection:
				depotConnection.backend_exit()
			raise
	
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                      OPSIPACKAGEMANAGERCONTROL                                    -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class OpsiPackageManagerControl(object):
	def __init__(self):
		logger.debug(u"OpsiPackageManagerControl")
		# Set umask
		os.umask(0077)
		self._pid = 0
		
		# Call signalHandler on signal SIGTERM, SIGINT
		signal(SIGTERM, self.signalHandler)
		signal(SIGINT,  self.signalHandler)
		
		parser = OptionParser( add_help_option = False )
		
		parser.add_option("-h", "--help",           action="store_true", dest="help")
		parser.add_option("-V", "--version",        action="store_true", dest="version")
		parser.add_option("-v", "--verbose",        action="count",      dest="verbose")
		parser.add_option("-q", "--quiet",          action="store_true", dest="quiet")
		parser.add_option("-i", "--install",        action="store_true", dest="COMMAND_INSTALL")
		parser.add_option("-u", "--upload",         action="store_true", dest="COMMAND_UPLOAD")
		parser.add_option("-p", "--properties",     action="store",      dest="properties",   default="keep", choices=['ask', 'package', 'keep'])
		parser.add_option(      "--max-transfers",  action="store",      dest="maxTransfers", default = 0,    type="int")
		parser.add_option(      "--max-bandwidth",  action="store",      dest="maxBandwidth", default = 0,    type="int")
		parser.add_option("-l", "--list",           action="store_true", dest="COMMAND_LIST")
		parser.add_option("-D", "--differences",    action="store_true", dest="COMMAND_DIFFERENCES")
		parser.add_option("-r", "--remove",         action="store_true", dest="COMMAND_REMOVE")
		parser.add_option("-x", "--extract",        action="store_true", dest="COMMAND_EXTRACT")
		parser.add_option(      "--new-product-id", action="store",      dest="newProductId")
		parser.add_option("-d", "--depots",         action="store",      dest="depots")
		parser.add_option("-f", "--force",          action="store_true", dest="force")
		parser.add_option("-k", "--keep-files",     action="store_true", dest="keepFiles")
		parser.add_option("-t", "--temp-dir",       action="store",      dest="tempDir")
		parser.add_option("-o", "--overwrite",      action="store_true", dest="overwriteAlways")
		parser.add_option("-S", "--setup",          action="store_true", dest="setupWhereInstalled")
		parser.add_option("-U", "--update",         action="store_true", dest="updateWhereInstalled")
		parser.add_option(      "--interface",      action="store",      dest="interface",    default="snack", choices=['text', 'snack'])
		parser.add_option(      "--log-file",       action="store",      dest="logFile")
		
		# Get commandline options and arguments
		try:
			(self.opts, self.args) = parser.parse_args()
		except Exception:
			self.usage()
			sys.exit(1)
		
		self.setDefaultConfig()
		
		if self.opts.help:
			usage()
			sys.exit(0)
		
		if self.opts.version:
			print u"opsi-package-manager version %s" % __version__
			sys.exit(0)
		
		self.setCommandlineConfig()
		
		self.backend = BackendManager(
			backendConfigDir   = self.config['backendConfigDir'],
			dispatchConfigFile = self.config['dispatchConfigFile']
		)
		
		knownDepotIds = self.backend.host_getIdents(type = 'OpsiDepotserver', returnType = 'unicode')
		knownDepotIds.sort()
		if not self.config['depotIds']:
			try:
				self.config['depotIds'] = [ forceHostId(socket.getfqdn()) ]
			except Exception, e:
				raise Exception(u"Failed to get local depot id: %s" % e)
		
		for i in range(len(self.config['depotIds'])):
			if (self.config['depotIds'][i].lower() == 'all'):
				self.config['depotIds'] = knownDepotIds
				break
			else:
				depotId = forceHostId(self.config['depotIds'][i])
				if not depotId in knownDepotIds:
					raise Exception(u"Depot '%s' not in list of known depots: %s" % (depotId, u', '.join(knownDepotIds)))
				self.config['depotIds'][i] = depotId
		self.config['depotIds'].sort()
		
		if self.config['command'] in (u'install', u'upload', u'extract'):
			if (len(self.config['packageFiles']) < 1):
				raise Exception(u"No opsi package given")
			if self.config['command'] in (u'install', u'upload', u'extract'):
				for i in range(len(self.config['packageFiles'])):
					self.config['packageFiles'][i] = os.path.abspath(self.config['packageFiles'][i])
					if not os.path.exists(self.config['packageFiles'][i]):
						raise Exception(u"Package file '%s' does not exist or access denied" % self.config['packageFiles'][i])
			if (self.config['command'] == u'extract') and self.config['newProductId'] and (len(self.config['packageFiles']) > 1):
				raise Exception(u"Cannot use new product id with multiple package files")
		
		elif self.config['command'] in (u'list', u'differences'):
			if not self.config['productIds']:
				self.config['productIds'] = ['*']
			if (self.config['command'] == u'differences') and (len(self.config['depotIds']) <= 1):
				raise Exception(u"More than one depot id needed to display differences")
			
		elif self.config['command'] in (u'remove'):
			if not self.config['productIds']:
				raise Exception(u"No opsi product id given")
		
		logger.setLogFormat(u'[%l] [%D] %M (%F|%N)')
		if self.config['logFile']:
			if os.path.exists(self.config['logFile']):
				os.unlink(self.config['logFile'])
			logger.setLogFile(self.config['logFile'])
			logger.setFileLevel(self.config['fileLogLevel'])
		
		logger.setConsoleLevel(self.config['consoleLogLevel'])
		logger.setConsoleColor(True)
		
		try:
			self.processCommand()
		except Exception, e:
			logger.logException(e)
			raise Exception(u"Failed to process command '%s': %s" % (self.config['command'], e))
		
		if self.backend:
			self.backend.backend_exit()
		
	def processCommand(self):
		self._opm = OpsiPackageManager(self.config, self.backend)
		
		if   (self.config['command'] == u'list'):
			self.processListCommand()
		elif (self.config['command'] == u'differences'):
			self.processDifferencesCommand()
		elif (self.config['command'] == u'upload'):
			self.processUploadCommand()
		elif (self.config['command'] == u'remove'):
			self.processRemoveCommand()
	
	def processListCommand(self):
		terminalWidth = 60
		try:
			tty = os.popen('tty').readline().strip()
			fd = open(tty)
			terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
			fd.close()
		except:
			pass
		
		indent = u"   "
		idWidth = versionWidth = int((terminalWidth-len(indent))/3)
		if (idWidth > 25): idWidth = 25
		if (versionWidth > 25): versionWidth = 25
		descriptionWidth = terminalWidth-len(indent)-idWidth-versionWidth-4
		
		productOnDepots = self.backend.productOnDepot_getObjects(depotId = self.config['depotIds'], productId = self.config['productIds'])
		products = self.backend.product_getObjects(id = self.config['productIds'])
		
		productInfo = {}
		for product in products:
			if not productInfo.has_key(product.id):
				productInfo[product.id] = {}
			if not productInfo[product.id].has_key(product.productVersion):
				productInfo[product.id][product.productVersion] = {}
			productInfo[product.id][product.productVersion][product.packageVersion] = product
		
		productOnDepotInfo = {}
		for depotId in self.config['depotIds']:
			productOnDepotInfo[depotId] = {}
		for productOnDepot in productOnDepots:
			productOnDepotInfo[productOnDepot.depotId][productOnDepot.productId] = productOnDepot
		
		for (depotId, values) in productOnDepotInfo.items():
			print u"-"*(len(depotId)+4)
			print u"- %s -" % depotId
			print u"-"*(len(depotId)+4)
			print u"%s%*s %*s %*s" % (indent, -1*idWidth, u'Product ID',
						-1*versionWidth, u'Version',
						-1*descriptionWidth, u'Description')
			print u"%s%s" % (indent, "="*(terminalWidth-len(indent)-2))
			productIds = values.keys()
			productIds.sort()
			for productId in productIds:
				productOnDepot = productOnDepotInfo[depotId][productId]
				product = productInfo[productOnDepot.productId][productOnDepot.productVersion][productOnDepot.packageVersion]
				print u"%s%*s %*s %*s" % (indent, -1*idWidth, productId,
						-1*versionWidth,     product.productVersion + u'-' + product.packageVersion,
						-1*descriptionWidth, product.description.replace(u'\n', u'')[:descriptionWidth])
			print u""
		
	def processDifferencesCommand(self):
		productOnDepots = self.backend.productOnDepot_getObjects(depotId = self.config['depotIds'], productId = self.config['productIds'])
		productOnDepotInfo = {}
		productIds = []
		maxWidth = 0
		for depotId in self.config['depotIds']:
			if (len(depotId) > maxWidth):
				maxWidth = len(depotId)
			productOnDepotInfo[depotId] = {}
		for productOnDepot in productOnDepots:
			if not productOnDepot.productId in productIds:
				productIds.append(productOnDepot.productId)
			productOnDepotInfo[productOnDepot.depotId][productOnDepot.productId] = productOnDepot
		productIds.sort()
		
		for productId in productIds:
			differs = False
			lines = []
			lines.append(productId)
			productVersion = u''
			packageVersion = u''
			for depotId in self.config['depotIds']:
				lines.append(u"    %*s: " % (-1*maxWidth, depotId))
				productOnDepot = productOnDepotInfo[depotId].get(productId)
				if not productOnDepot:
					lines[-1] += u" not installed"
					differs = True
					continue
				
				if not productVersion:
					productVersion = productOnDepot.productVersion
				elif (productVersion != productOnDepot.productVersion):
					differs = True
				
				if not packageVersion:
					packageVersion = productOnDepot.packageVersion
				elif (packageVersion != productOnDepot.packageVersion):
					differs = True
				
				lines[-1] += u" %s-%s" % ( productOnDepot.productVersion, productOnDepot.packageVersion)
				
			if differs:
				for line in lines:
					print line
				print ""
	
	def processUploadCommand(self):
		self._opm.uploadToRepositories()
		
	def processRemoveCommand(self):
		self._opm.uninstallPackages()
	
	def setDefaultConfig(self):
		self.config = {
			'fileLogLevel'           : LOG_DEBUG2,
			'consoleLogLevel'        : LOG_NONE,
			'logFile'                : None,
			'interface'              : u'snack',
			'tempDir'                : u'/tmp',
			'backendConfigDir'       : u'/etc/opsi/backends',
			'dispatchConfigFile'     : u'/etc/opsi/backendManager/dispatch.conf',
			'command'                : None,
			'packageFiles'           : [],
			'productIds'             : [],
			'properties'             : u'keep',
			'maxTransfers'           : 0,
			'maxBandwidth'           : 0,
			'deltaUpload'            : True,
			'newProductId'           : None,
			'depotIds'               : None,
			'forceInstall'           : False,
			'forceUninstall'         : False,
			'deleteFilesOnUninstall' : True,
			'overwriteAlways'        : False,
			'setupWhereInstalled'    : False,
			'updateWhereInstalled'   : False
		}
	
	def setCommandlineConfig(self):
		if (self.opts.properties == 'ask') and self.opts.quiet:
			raise Exception(u"You cannot use properties=ask in quiet mode")
		
		if self.opts.logFile:
			self.config['logFile'] = self.opts.logFile
		
		if self.opts.quiet:
			self.config['interface'] = u'dummy'
		elif self.opts.verbose:
			self.config['consoleLogLevel'] = LOG_WARNING + self.opts.verbose
		
		if self.opts.depots:
			self.config['depotIds'] = self.opts.depots.split(',')
			
		if self.opts.newProductId:
			self.config['newProductId'] = self.opts.newProductId
		
		if self.opts.maxBandwidth:
			self.config['maxBandwidth'] = self.opts.maxBandwidth * 1024
		
		if self.opts.overwriteAlways:
			self.config['overwriteAlways'] = self.opts.overwriteAlways
		
		if self.opts.keepFiles:
			self.config['deleteFilesOnUninstall'] = False
		
		if self.opts.force:
			self.config['forceInstall'] = True
			self.config['forceUninstall'] = True
		
		# Get command
		if self.opts.COMMAND_INSTALL:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'install'
		if self.opts.COMMAND_UPLOAD:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'upload'
		if self.opts.COMMAND_LIST:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'list'
		if self.opts.COMMAND_REMOVE:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'remove'
		if self.opts.COMMAND_EXTRACT:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'extract'
		if self.opts.COMMAND_DIFFERENCES:
			if self.config['command']:
				raise Exception(u"More than one command specified")
			self.config['command'] = u'differences'
		
		if not self.config['command']:
			raise Exception(u"No command specified")
		
		if   self.config['command'] in (u'install', u'upload', u'extract'):
			self.config['packageFiles'] = self.args
		
		elif self.config['command'] in (u'remove', u'list', u'differences'):
			self.config['productIds'] = self.args
			
	def signalHandler(self, signo, stackFrame):
		for thread in threading.enumerate():
			logger.debug(u"Running thread before signal: %s" % thread)
		
		if (signo == SIGTERM or signo == SIGINT):
			if self._opm:
				self._opm.abort()
		
		for thread in threading.enumerate():
			logger.debug(u"Running thread after signal: %s" % thread)
	
	def usage(self):
		print u"\nUsage: %s [options] <command>" % os.path.basename(sys.argv[0])
		print u""
		print u"Manage opsi packages"
		print u""
		print u"Commands:"
		print u"  -i, --install      <opsi-package> ...      install opsi packages"
		print u"  -u, --upload       <opsi-package> ...      upload opsi packages to repositories"
		print u"  -l, --list         <regex>                 list opsi packages matching regex"
		print u"  -D, --differences  <regex>                 show depot differences of opsi packages matching regex"
		print u"  -r, --remove       <opsi-product-id> ...   uninstall opsi packages"
		print u"  -x, --extract      <opsi-package> ...      extract opsi packages to local directory"
		print u"  -V, --version                              show program's version info and exit"
		print u"  -h, --help                                 show this help message and exit"
		print u""
		print u"Options:"
		print u"  -v, --verbose                    increase verbosity (can be used multiple times)"
		print u""
		print u"  -q, --quiet                      do not display any messages"
		print u""
		print u"  --log-file         <log-file>    path to debug log file"
		print u""
		print u"  -d, --depots       <depots>      comma separated list of depot ids to process"
		print u"			 	  use keyword ALL to process all known depots"
		print u""
		print u"  -p, --properties   <mode>        mode for default product property values"
		print u"		                      ask     = display dialog"
		print u"		                      package = use defaults from package"
		print u"		                      keep    = keep depot defaults (default)"
		print u""
		print u"  -f, --force                      force install/uninstall (use with extreme caution)"
		print u""
		print u"  -U, --update                     set action \"update\" on hosts where installation status is \"installed\""
		print u""
		print u"  -S, --setup                      set action \"setup\" on hosts where installation status is \"installed\""
		print u""
		print u"  -o, --overwrite                  overwrite existing package on upload even if size matches"
		print u""
		print u"  -k, --keep-files                 do not delete client data dir on uninstall"
		print u""
		print u"  -t, --temp-dir     <path>        tempory directory for package install"
		print u""
		print u"  --max-transfers    <num>         maximum number of simultaneous uploads"
		print u"                                      0 = unlimited (default)"
		print u""
		print u"  --max-bandwidth    <kbps>        maximum transfer rate for each transfer (in kilobytes per second)"
		print u"                                      0 = unlimited (default)"
		print u""
		print u"  --new-product-id   <product-id>  set a new product id when extracting opsi package"
		print u""
		print u"  --interface        <type>        type of user interface"
		print u"		                      text  = text based interface"
		print u"		                      snack = newt interface (default)"
		print u""


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                               MAIN                                                -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (__name__ == "__main__"):
	exception = None
	
	try:
		OpsiPackageManagerControl()
		
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, u"ERROR:", unicode(exception)
		sys.exit(1)
	sys.exit(0)


