#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
opsi-convert

opsi-convert is part of the desktop management solution opsi
(open pc server integration) http://www.opsi.org

Copyright (C) 2007-2013 uib GmbH

http://www.uib.de/

All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

@copyright:	uib GmbH <info@uib.de>
@author: Jan Schneider <j.schneider@uib.de>
@license: GNU General Public License version 2
"""

__version__ = '4.0.2.1'

import fcntl
import getopt
import getpass
import os
import re
import struct
import sys
import termios

from OPSI.Logger import LOG_NONE, LOG_ERROR, Logger
from OPSI.Types import forceUnicode, forceHostId
from OPSI.Util import getfqdn
from OPSI.Util.Message import ProgressObserver
from OPSI.Backend.BackendManager import BackendManager
from OPSI.Backend.Replicator import BackendReplicator

logLevel = LOG_NONE
logger = Logger()
logger.setConsoleLevel(logLevel)
logger.setConsoleFormat('%M')
logger.setFileFormat('%D [%L] %M')
logger.setConsoleColor(True)


def usage():
	print u"\nUsage: %s [options] <from> <to>" % os.path.basename(sys.argv[0])
	print u"Convert an opsi database into an other."
	print u"Options:"
	print u"    -h                 show this help text"
	print u"    -V                 show version information"
	print u"    -q                 do not show progress"
	print u"    -v                 increase verbosity (can be used multiple times)"
	print u"    -c                 clean destination database before writing"
	print u"    -a                 including software/hardware inventory"
	print u"    -s <old server id> use destination host as new server"
	print u"    -l <file>          log to this file"
	print u""
	print u"<from> and <to> can be:"
	print u"     - the name of a backend as defined in /etc/opsi/backends (file, ldap, ...)"
	print u"     - the url of a opsi configuration service"
	print u"       http(s)://<user>@<host>:<port>/rpc"
	print u""


class ProgressNotifier(ProgressObserver):
	def __init__(self, backendReplicator):
		self.usedWidth = 120
		self.currentProgressSubject = backendReplicator.getCurrentProgressSubject()
		self.overallProgressSubject = backendReplicator.getOverallProgressSubject()
		self.currentProgressSubject.attachObserver(self)
		self.overallProgressSubject.attachObserver(self)
		self.logSubject = logger.getMessageSubject()
		self.logSubject.attachObserver(self)
		logger.setMessageSubjectLevel(LOG_ERROR)
		self.error = None

	def displayProgress(self):
		usedWidth = self.usedWidth
		try:
			tty = os.popen('tty').readline().strip()
			fd = open(tty)
			terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
			if usedWidth > terminalWidth:
				usedWidth = terminalWidth
			fd.close()
		except:
			pass

		if logLevel <= LOG_NONE:
			sys.stdout.write("\033[2A")
		if self.error:
			sys.stdout.write("\033[K")
			print u"Error occured: %s" % self.error
			sys.stdout.write("\033[K")
		self.error = None
		for subject in self.overallProgressSubject, self.currentProgressSubject:
			text = u''
			if subject is self.overallProgressSubject:
				text = u'Overall progress'
			else:
				text = subject.getTitle()
			barlen = usedWidth - 62
			filledlen = int("%0.0f" % (barlen * subject.getPercent() / 100))
			bar = u'='*filledlen + u' '*(barlen - filledlen)
			percent = '%0.2f%%' % subject.getPercent()
			print '%35s : %8s [%s] %5s/%-5s' % (text, percent, bar, subject.getState(), subject.getEnd())

	def progressChanged(self, subject, state, percent, timeSpend, timeLeft, speed):
		self.displayProgress()

	def messageChanged(self, subject, message):
		if subject == self.logSubject:
			self.error = message
		self.displayProgress()


def main(argv):
	global logLevel
	newServerId = None
	oldServerId = None
	cleanupFirst = False
	convertAudit = False
	progress = True

	# Get options
	try:
		(opts, args) = getopt.getopt(argv, "aqhvVcs:l:")

	except getopt.GetoptError:
		usage()
		sys.exit(1)

	for (opt, arg) in opts:
		if   (opt == "-h"):
			usage()
			return
		elif (opt == "-V"):
			print u"%s %s" % (os.path.basename(sys.argv[0]), __version__)
			return
		elif (opt == "-v"):
			logLevel += 1
			logger.setConsoleLevel(logLevel)
			logger.setFileLevel(logLevel)
		elif (opt == "-c"):
			cleanupFirst = True
		elif (opt == "-s"):
			newServerId = getfqdn(conf='/etc/opsi/global.conf')
			oldServerId = forceHostId(arg)
		elif (opt == "-q"):
			progress = False
		elif (opt == "-l"):
			logger.setLogFile(arg)
			logger.setFileLevel(logLevel)
		elif (opt == "-a"):
			convertAudit = True

	if len(args) < 2:
		usage()
		sys.exit(1)

	readBackend  = forceUnicode(args[0])
	writeBackend = forceUnicode(args[1])

	# Define read/write backend
	read = {
		'username'	: u'',
		'password'	: u'',
		'address'	: u'',
		'backend'	: u'' }
	write = {
		'username'	: u'',
		'password'	: u'',
		'address'	: u'',
		'backend'	: u'' }

	logger.comment(u"Converting from backend '%s' to backend '%s'." % (readBackend, writeBackend) )

	# Parse read backend
	match = re.search('^(\w+://)', readBackend)
	if match:
		# Seems to be an URL
		match = re.search('^(\w+://)([^@]+)@([^:]+:\d+/.*)$', readBackend)
		if match:
			read['backend']  = 'JSONRPC'
			read['address']  = match.group(1) + match.group(3)
			read['username'] = match.group(2)
		else:
			raise Exception(u"Bad source URL '%s'" % readBackend)
	else:
		# Assuming a backend name
		read['backend'] = readBackend

	# Parse write backend
	match = re.search('^(\w+://)', writeBackend)
	if match:
		# Seems to be an URL
		match = re.search('^(\w+://)([^@]+)@([^:]+:\d+/.*)$', writeBackend)
		if match:
			write['backend']  = 'JSONRPC'
			write['address']  = match.group(1) + match.group(3)
			write['username'] = match.group(2)
			if newServerId:
				newServerId = match.group(3).split(':')[0]
				if re.search('^[\d\.]+$', newServerId):
					# Is an ip address
					newServerId = getfqdn(name=newServerId)
					if re.search('^[\d\.]+$', newServerId):
						raise Exception(u"Cannot resolve '%s'" % newServerId)
		else:
			raise Exception(u"Bad destination URL '%s'" % writeBackend)
	else:
		# Assuming a backend name
		write['backend'] = writeBackend

	# Sanity checks
	if read['backend'] and write['backend']:
		if read['backend'] == write['backend']:
			if read['backend'] == 'JSONRPC':
				if read['address'] == write['address']:
					raise Exception(u"Source and destination backend are the same.")
			else:
				raise Exception(u"Source and destination backend are the same.")

	if newServerId:
		try:
			newServerId = forceHostId(newServerId)
		except:
			raise Exception(u"Bad server-id '%s' for new server" % newServerId)

	# Creating BackendManager instance for reading
	bmRead = None
	if read['address']:
		logger.comment( u"Connecting to %s" % read['address'] )
		read['password'] = getpass.getpass()

	bmRead = BackendManager(backendConfigDir = u'/etc/opsi/backends', **read)

	# Creating BackendManager instance for writing
	bmWrite = None
	if read['address']:
		logger.comment( u"Connecting to %s" % bmWrite['address'] )
		write['password'] = getpass.getpass()

	bmWrite = BackendManager(backendConfigDir = u'/etc/opsi/backends', **write)

	backendReplicator = BackendReplicator(
		readBackend  = bmRead,
		writeBackend = bmWrite,
		newServerId  = newServerId,
		oldServerId  = oldServerId,
		cleanupFirst = cleanupFirst
	)
	if progress:
		progressNotifier = ProgressNotifier(backendReplicator)
		print ""
	backendReplicator.replicate(audit = convertAudit)


if __name__ == "__main__":
	try:
		main(sys.argv[1:])
	except SystemExit:
		pass
	except Exception as e:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(e)
		print >> sys.stderr, u"ERROR: %s" % e
		sys.exit(1)

	sys.exit(0)
