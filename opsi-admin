#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = =
   =   opsi-admin    =
   = = = = = = = = = =
   
   opsi-admin is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2007,2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '0.9.9.2'

import os, sys, termios, getopt, time, fcntl, struct, gettext, json, popen2

# OPSI imports    
from OPSI import Tools
from OPSI.Logger import *
from OPSI.Backend.BackendManager import *
from OPSI.Backend.Backend import *

import curses

# Globals
backend = None
shell = None
logFile = None
logLevel = LOG_NONE
logger = Logger()
interactive = False



LOGO =[	{"color": COLOR_GREEN, "text": '                                .. ....                        '},
	{"color": COLOR_GREEN, "text": '                               JM##""WMF                       '},
	{"color": COLOR_GREEN, "text": '                               MM    MM5                       '},
	{"color": COLOR_GREEN, "text": '                               JMNNNMMF                        '},
	{"color": COLOR_GREEN, "text": '                               ..x???&..                       '},
	{"color": COLOR_GREEN, "text": '                               "WMMMMMM                        '},
	{"color": COLOR_GREEN, "text": '                                                               '},
	{"color": COLOR_GREEN, "text": '                               ...&Na...                       '},
	{"color": COLOR_GREEN, "text": '                          ..JMMMMMMMMMMMMM&.                   '},
	{"color": COLOR_GREEN, "text": '                        .MMMM"^   JM   ."WMMM&.                '},
	{"color": COLOR_GREEN, "text": '                      .MMMY! ...           ?WMMx               '},
	{"color": COLOR_GREEN, "text": '                     .MM#!  JMM5.NMMMMMMMMa  ?MMh              '},
	{"color": COLOR_GREEN, "text": '                    .MM@   JMMFJ""""""""MMMr  .MMb     .   ..  '},
	{"color": COLOR_GREEN, "text": '         JM.NNNNp   MMM    MMM         JMMM    JMMF   JMMMMMMM.'},
	{"color": COLOR_GREEN, "text": '        JMF!!.JMM  JMMF    MMM         MMMF     MMN.  MF   .MM '},
	{"color": COLOR_GREEN, "text": '        JMb...JM$  MMMMMN: JMMp      .JMM@   .uMMMMF  4MNa&MM5 '},
	{"color": COLOR_GREEN, "text": '         J"WMM#5   4MMF     TMMMMMMMMMMM@       MM#! ...?""7i. '},
	{"color": COLOR_GREEN, "text": '        4MMN&&MMF   MMM      .""""MMM#"^       .MMF  .YMMMMMM@ '},
	{"color": COLOR_GREEN, "text": '          ?"""""    JMMh  ......       ...&.  .MMF             '},
	{"color": COLOR_GREEN, "text": '                     JMMN.JMMMMMMMMMMMMMMM^  .MM@              '},
	{"color": COLOR_GREEN, "text": '                      JMMMa..""MMMMMMMWMM"^.MMMD               '},
	{"color": COLOR_GREEN, "text": '                        ?MMMNx.   !!   ..&MMM"                 '},
	{"color": COLOR_GREEN, "text": '                          .TMMMMMMMMMMMMMM"^                   '},
	{"color": COLOR_GREEN, "text": '                              .?""""""^!                       '},
	{"color": COLOR_GREEN, "text": '      opsi-admin %-10s                                    ' % __version__},
	{"color": COLOR_GREEN, "text": '                                                               '} ]
	

# Get locale
try:
	t = gettext.translation('opsi-admin', LOCALE_DIR)
	_ = t.ugettext
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string


def signalHandler(signo, stackFrame):
	logger.info("Received signal %s" % signo)
	if (signo == SIGINT):
		shell.sigint()
	if (signo == SIGQUIT):
		sys.exit(0)
	
def usage():
	print _("\nUsage: %s [options] [command] [args...]") % os.path.basename(sys.argv[0])
	print _("Options:")
	print _("  -h, --help           Display this text")
	print _("  -V, --version        Display this text")
	print _("  -u, --username       Username (default: current user)")
	print _("  -p, --password       Password (default: prompt for password)")
	print _("  -a, --address        URL of opsiconfd (default: https://localhost:4447/rpc)")
	print _("  -d, --direct         Do not use opsiconfd")
	print _("  -l, --loglevel       Set log level (default: 2)")
	print _("                       0=nothing, 1=critical, 2=error, 3=warning, 4=notice, 5=info, 6=debug")
	print _("  -f, --log-file       Path to log file")
	print _("  -i, --interactive    Start in interactive mode")
	print _("  -c, --colorize       Colorize output")
	print _("  -S, --simple-output  Simple output (only for scalars, lists)")
	print _("  -s, --shell-output   Shell output")
	print ""
	
def main(argv):
	os.umask(077)
	global interactive
	
	logLevel = LOG_NONE
	username = ''
	try:
		import pwd
		username = pwd.getpwuid(os.getuid())[0]
	except:
		pass
	
	password = ''
	address = 'https://localhost:4447/rpc'
	output = 'NICE'
	color = False
	direct = False
	
	try:
		(opts, args) = getopt.getopt(argv, "u:p:a:l:f:dicsShV", 
					[ "username=", "password=", "address=", 
					  "loglevel=", "log-file=", "interactive", "direct",
					  "colorize", "shell-output", "simple-output", "help", "version" ])

	except getopt.GetoptError:
		usage()
		sys.exit(1)
	
	for (opt, arg) in opts:
		if   opt in ("-h", "--help"):
			usage()
			sys.exit(0)
		elif opt in ("-V", "--version"):
			print "%s %s" % (os.path.basename(sys.argv[0]), __version__)
			sys.exit(0)
		elif opt in ("-u", "--username"):
			username = arg
		elif opt in ("-p", "--password"):
			password = arg
		elif opt in ("-l", "--loglevel"):
			logLevel = int(arg)
		elif opt in ("-f", "--log-file"):
			global logFile
			logFile = arg
		elif opt in ("-a", "--address"):
			address = arg
		elif opt in ("-d", "--direct"):
			direct = True
		elif opt in ("-i", "--interactive"):
			interactive = True
		elif opt in ("-c", "--colorize"):
			color = True
		elif opt in ("-s", "--shell-output"):
			output = 'SHELL'
		elif opt in ("-S", "--simple-output"):
			output = 'SIMPLE'
		
	if logFile:
		f = open(logFile, 'w')
		print >> f, "Starting log at: %s" % time.strftime("%a, %d %b %Y %H:%M:%S")
		f.close()
		logger.setLogFile(logFile)
		logger.setFileLevel(logLevel)
		
	logger.setConsoleLevel(logLevel)
	logger.setColor(color)
	
	if interactive:
		logger.setConsoleLevel(LOG_NONE)
	
	global backend
	
	if direct:
		# Create BackendManager
		from OPSI.Backend.BackendManager import BackendManager
		backend = BackendManager(authRequired=False)
	
	else:
		# Connect to opsiconfd
		if not password:
			try:
				import getpass
				password = getpass.getpass()
			except:
				pass
		
		if not os.path.exists( os.path.join(os.environ.get('HOME'), '.opsi-admin') ):
			os.mkdir( os.path.join(os.environ.get('HOME'), '.opsi-admin') )
		
		sessionId = None
		try:
			session = open( os.path.join(os.environ.get('HOME'), '.opsi-admin', 'session') )
			for line in session.readlines():
				line = line.strip()
				if line:
					sessionId = line
					break
			session.close()
		except Exception, e:
			logger.error("Cannot read session file '%s': %s" \
				% (os.path.join(os.environ.get('HOME'), '.opsi-admin', 'session'), e))
		
		
		from OPSI.Backend.JSONRPC import JSONRPCBackend
		backend = JSONRPCBackend(	address	 = 	address, 
						username =	username,
						password = 	password,
						args	 =	{ 'sessionId': sessionId } )
		
		logger.info('Connected.')
		
		sessionId = backend.getSessionId()
		if sessionId:
			try:
				session = open( os.path.join(os.environ.get('HOME'), '.opsi-admin', 'session'), 'w' )
				print >> session, sessionId
				session.close()
			except Exception, e:
				logger.error("Cannot write session file '%s': %s" \
					% (os.path.join(os.environ.get('HOME'), '.opsi-admin', 'session'), e))
	
	
	cmdline = ''
	if (len(args) > 0):
		for i in range(len(args)):
			logger.info("arg[%d]: %s" % (i, args[i]))
			if (i == 0):
				cmdline = str(args[i])
			elif (str(args[i]).find(' ') != -1) or (len(str(args[i])) == 0):
				cmdline += " '%s'" % args[i]
			else:
				cmdline += " %s" % args[i]
	
	if not cmdline:
		import select
		(r, w, x) = select.select([ sys.stdin ], [], [], 0.2)
		if sys.stdin in r:
			cmdline = sys.stdin.read()
	
	#logger.notice("cmdline: '%s'" % cmdline)
	
	global shell
	if interactive:
		logger.notice("Starting interactive mode")
		shell = Shell(prompt = '%s@opsi-admin>' % username, output = output, color = color, cmdline = cmdline)
		shell.setInfoline("Connected to %s" % address)
		
		for line in LOGO:
			shell.appendLine(line.get('text'), line.get('color'))
		shell.run()
	
	elif cmdline:
		shell = Shell(prompt = '%s@opsi-admin>' % username, output = output, color = color)
		for cmd in cmdline.split('\n'):
			if cmd:
				shell.cmdline = cmd
				shell.execute()
		
		logger.debug(shell.getLines())
		for line in shell.lines:
			print >> sys.stdout, line['text'].rstrip()
		
	
	else:
		usage()
		sys.exit(1)
	
	

class Shell:
	
	def __init__(self, prompt='opsi-admin>', output='NICE', color=True, cmdline=''):
		self.color = color
		self.output = output
		self.running = False
		self.screen = None
		self.cmdBufferSize = 1024
		self.userConfigDir = None
		self.prompt = prompt
		self.infoline = 'opsi admin started'
		self.yMax = 0
		self.xMax = 4096
		self.pos = len(cmdline)
		self.lines = []
		self.linesBack = 0
		self.linesMax = 0
		self.paramPos = -1
		self.currentParam = None
		self.cmdListPos = 0
		self.cmdList = []
		self.cmdline = cmdline
		self.shellCommand = ''
		self.reverseSearch = None
		self.commands = [
			CommandMethod(),
			CommandSet(),
			CommandHelp(),
			CommandQuit(),
			CommandExit(),
			CommandHistory(),
			CommandLog(),
			CommandTask() ]
		
		home = os.environ.get('HOME')
		if home:
			self.userConfigDir = os.path.join(home, '.opsi-admin')
			if not os.path.isdir(self.userConfigDir):
				try:
					os.mkdir(self.userConfigDir)
				except Exception, e:
					logger.error("Cannot create user-settings dir '%s': %s" % (self.userConfigDir, e))
		else:
			logger.error('Cannot get home directory from environment!')
		
		try:
			history = open( os.path.join(self.userConfigDir, 'history') )
			for line in history.readlines():
				if not line:
					continue
				self.cmdList.append(line.strip())
				self.cmdListPos += 1
			history.close()
		except Exception, e:
			logger.error("Cannot read history file '%s': %s" % (self.userConfigDir + os.sep + 'history', e))
		
	def setColor(self, color):
		color = bool(color)
		if (color != self.color):
			self.color = color
			self.initScreen()
		
	def getLines(self):
		return self.lines
	
	def initScreen(self):
		self.screen = curses.initscr()
		curses.noecho()
		curses.cbreak()
		self.screen.keypad(1)
		self.screen.clear()
		
		self.yMax, self.xMax = self.screen.getmaxyx()
		self.linesMax = self.yMax-2
		
		if self.color:
			curses.start_color()
			
			curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
			curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
			curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
			curses.init_pair(4, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
			curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)
			
	def sigint(self):
		self.pos = 0
		self.setCmdline('')
		self.reverseSearch = None
	
	def run(self):
		#logger.debug("run")
		self.running = True
		
		self.initScreen()
		
		if self.cmdline:
			for cmd in self.cmdline.split('\n'):
				self.cmdline = cmd
				self.appendLine(self.prompt + ' ' + self.cmdline)
				if self.cmdline:
					try:
						self.execute()
					except Exception, e:
						lines = str(e).split('\n')
						lines[0] = "ERROR: %s" % lines[0]
						for line in lines:
							self.appendLine(line, COLOR_RED)
						
				if (len(self.lines) > self.yMax-2):
					self.linesBack = 0
					#logger.debug("linesBack: %s" % self.linesBack)
		else:
			self.display()
		
		while self.running:
			self.getCommand()
		
		
	def exit(self):
		if interactive and logFile and os.path.exists(logFile):
			if self.question("Delete log-file '%s'?" % logFile):
				try:
					os.unlink(logFile)
				except Exception, e:
					logger.error("Cannot delete log-file '%s': %s" % (logFile, e))
		try:
			history = open( os.path.join(self.userConfigDir, 'history'), 'w')
			for line in self.cmdList:
				if not line or line in ('quit', 'exit'):
					continue
				print >> history, line
			history.close()
		except Exception, e:
			logger.error("Cannot write history file '%s': %s" % (os.path.join(self.userConfigDir, 'history'), e))
		
		
		if self.screen:	
			curses.nocbreak() 
			self.screen.keypad(0)
			curses.echo()
			curses.endwin()
		self.running = False
		sys.exit(0)
	
	def bell(self):
		sys.stderr.write('\a')
		
	def display(self):
		if not self.screen:
			return
		self.screen.move(0, 0)
		self.screen.clrtoeol()
		s = self.infoline + (self.xMax - len(self.infoline))*' '
		try:
			self.screen.addstr(s, curses.A_REVERSE)
		except Exception, e:
			logger.error("Failed to add string '%s': %s" % (s, e))
		
		height = int(len(self.prompt + ' ' + self.cmdline) / self.xMax) + 1
		clear = self.xMax - (len(self.prompt + ' ' + self.cmdline) % self.xMax) -1
		#logger.debug( "cmdline: %s, height: %s" % (self.cmdline, height) )
		self.linesMax = self.yMax - height - 1
		self.screen.move(self.yMax - height, 0)
		self.screen.clrtoeol()
		s = self.prompt + ' ' + self.cmdline + ' '*clear
		try:
			self.screen.addstr(s, curses.A_BOLD)
		except Exception, e:
			logger.error("Failed to add string '%s': %s" % (s, e))
		
		for i in range(0, self.linesMax):
			self.screen.move(self.linesMax-i, 0)
			self.screen.clrtoeol()
			s = ""
			color = None
			if (len(self.lines)-self.linesBack > i):
				s = self.lines[len(self.lines)-self.linesBack-1-i]['text']
				if self.color:
					color = self.lines[len(self.lines)-self.linesBack-1-i]['color']
			if color: 
				if   (color == COLOR_NORMAL):		color = curses.A_BOLD
				elif (color == COLOR_GREEN):		color = curses.color_pair(1)
				elif (color == COLOR_LIGHT_WHITE):	color = curses.A_BOLD
				elif (color == COLOR_YELLOW):		color = curses.color_pair(3)
				elif (color == COLOR_LIGHT_RED):	color = curses.color_pair(4)
				elif (color == COLOR_RED):		color = curses.color_pair(5)
			
			try:
				if (color != None):
					self.screen.addstr(s, color)
				else:
					self.screen.addstr(s)
			except Exception, e:
				logger.error("Failed to add string '%s': %s" % (s, e))
			
		moveY = self.yMax - height + int( (len(self.prompt + ' ') + self.pos) / self.xMax)
		moveX = ( (len(self.prompt + ' ') + self.pos) % self.xMax)
		#logger.debug("cmdline move => pos:%s, x:%s, y:%s" % (self.pos, moveX, moveY))
		self.screen.move(moveY, moveX)
		self.screen.refresh()
		
	def appendLine(self, line, color=None, refresh = True):
		
		if not color:
			if   line.startswith(COLOR_NORMAL): 		color = COLOR_NORMAL
			elif line.startswith(COLOR_GREEN): 		color = COLOR_GREEN
			elif line.startswith(COLOR_LIGHT_WHITE): 	color = COLOR_LIGHT_WHITE
			elif line.startswith(COLOR_YELLOW): 		color = COLOR_YELLOW
			elif line.startswith(COLOR_LIGHT_RED):		color = COLOR_LIGHT_RED
			elif line.startswith(COLOR_RED): 		color = COLOR_RED
			
						
		for c in COLORS_AVAILABLE:
			line = line.replace(c, '')
		
		while (len(line) > self.xMax):
			self.lines.append( { "text": line[:self.xMax], "color": color } )
			line = line[self.xMax:]
		self.lines.append( { "text": line, "color": color } )
		if refresh:
			self.display()
		
		
	def setCmdline(self, cmdline, refresh = True):
		self.cmdline = cmdline
		if refresh:
			self.display()
	
	def setInfoline(self, infoline, refresh = True):
		self.infoline = infoline
		if refresh:
			self.display()
	
	def getParams(self):
		self.parseCmdline()
		return self.params
	
	def getParam(self, i):
		self.parseCmdline()
		if (len(self.params) >= i):
			return self.params[i]
		return ''
	
	def parseCmdline(self):
		self.params = []
		self.currentParam = None
		self.paramPos = -1
		
		if not self.cmdline:
			return
		
		cur = 0
		quote = None
		pipe = False
		self.shellCommand = ''
		
		for i in range(len(self.cmdline)):
			logger.debug2("parseCmdline(): char '%s', quote: %s, pipe: %s, cur: %d, params: %s" % (self.cmdline[i], quote, pipe, cur, self.params))
			if (pipe):
				self.shellCommand += self.cmdline[i]
				continue
			
			elif (not quote and self.cmdline[i] == "|"):
				pipe = True
				continue
			
			if (len(self.params) < cur+1):
				self.params.append('')
			
			if (i == self.pos-1):
				self.paramPos = cur
			
			if (self.cmdline[i] == "'"):
				if (quote == None):
					#self.params[cur] += '\''
					quote = "'"
				elif (quote == "'"):
					#self.params[cur] += '\''
					if not self.params[cur]:
						cur += 1
					quote = None
				else:
					self.params[cur] += '\''
			
			elif (self.cmdline[i] == '"'):
				if (quote == None):
					self.params[cur] += '"'
					quote = '"'
				elif (quote == '"'):
					self.params[cur] += '"'
					if not self.params[cur]:
						cur += 1
					quote = None
				else:
					self.params[cur] += '"'
			
			elif (self.cmdline[i] == " "):
				if (quote != None):
					self.params[cur] += self.cmdline[i]
				elif (len(self.params[cur]) > 0):
					cur += 1
			
			else:
				self.params[cur] += self.cmdline[i]
			
			
		
		if not quote and self.params[-1] and self.pos == len(self.cmdline) and self.cmdline.endswith(' '):
			self.params.append('')
			self.paramPos += 1
		
		self.currentParam = self.params[self.paramPos]
		
		logger.info("cmdline: %s" % self.cmdline)
		logger.debug2("paramPos: %s, currentParam: %s, params: %s" \
				% (self.paramPos, self.currentParam, self.params) )
		if ( self.paramPos >= len(self.params) ):
			logger.error("Assertion 'self.paramPos < len(self.params)' failed: " +
				"self.paramPos: %s, len(self.params): %s" % (self.paramPos, len(self.params)) )
			self.paramPos = len(self.params)-1
		

	
	def execute(self):
		logger.info("Execute: %s" % self.cmdline)
		self.cmdList.append(self.cmdline)
		if (len(self.cmdList) > self.cmdBufferSize):
			del self.cmdList[0]
		self.cmdListPos = len(self.cmdList)
		invalid = True
		for c in self.commands:
			if (c.getName() == self.getParam(0)):
				invalid = False
				try:
					c.execute(self, self.getParams()[1:])
				except Exception, e:
					logger.logException(e)
					logger.error("Failed to execute '%s': %s" % (self.cmdline, e))
					raise Exception("Failed to execute '%s': %s" % (self.cmdline, e))
				break
		
		if invalid:
			raise Exception(_("Invalid command"))
	
	def question(self, question):
		if interactive:
			self.screen.move(self.yMax-1, 0)
			self.screen.clrtoeol()
			self.screen.addstr(question + ' (n/y)')
			self.screen.refresh()
			char = None
			while True:
				char = self.screen.getch()
				if (char and char >= 0 and char < 256 and char != 10):
					if (chr(char) == 'y'):
						return True
					if (chr(char) == 'n'):
						return False
		return False
		
	def getPassword(self):
		password1 = ''
		password2 = ''
		while (not password1 or password1 != password2):
			if interactive:
				self.screen.move(self.yMax-1, 0)
				self.screen.clrtoeol()
				self.screen.addstr(_("Please type password:"))
				self.screen.refresh()
				password1 = ''
				char = None
				while not char or (char != 10):
					char = self.screen.getch()
					if (char and char >= 0 and char < 256 and char != 10):
						password1 += chr(char)
				
				self.screen.move(self.yMax-1, 0)
				self.screen.clrtoeol()
				self.screen.addstr(_("Please retype password:"))
				self.screen.refresh()
				password2 = ''
				char = None
				while not char or (char != 10):
					char = self.screen.getch()
					if (char and char >= 0 and char < 256 and char != 10):
						password2 += chr(char)
				
				if (password1 != password2):
					self.screen.move(self.yMax-1, 0)
					self.screen.clrtoeol()
					self.screen.addstr(_("Supplied passwords do not match"))
					self.screen.refresh()
					time.sleep(2)
			else:
				import getpass
				password1 = password2 = getpass.getpass()
			
		return password1
		
	def getCommand(self):
		char = None
		self.pos = 0
		self.setCmdline('')
		self.reverseSearch = None
		
		while not char or (char != 10):
			char = self.screen.getch()
			textInput = False
			
			if not char or char < 0:
				continue
			
			#self.infoline = "%s" % char
			#logger.debug("%s" % char)
			
			if (char == curses.KEY_RESIZE):
				# window resized
				self.yMax, self.xMax = self.screen.getmaxyx()
				self.display()
				continue
				
			elif (char == curses.KEY_UP):
				if len(self.cmdList) > 0 and self.cmdListPos > 0:
					self.cmdListPos -= 1
					self.pos = len(self.cmdList[self.cmdListPos])
					self.setCmdline(self.cmdList[self.cmdListPos])
			
			elif (char == curses.KEY_DOWN): 
				if len(self.cmdList) > 0 and self.cmdListPos < len(self.cmdList):
					self.cmdListPos += 1
					if (self.cmdListPos == len(self.cmdList)):
						self.pos = 0
						self.setCmdline('')
					else:
						self.pos = len(self.cmdList[self.cmdListPos])
						self.setCmdline(self.cmdList[self.cmdListPos])
			
			elif (char == curses.KEY_LEFT):
				if (self.pos > 0):
					self.pos -= 1
					self.setCmdline(self.cmdline)
			
			elif (char == curses.KEY_RIGHT):
				if ( self.pos < len(self.cmdline) ):
					self.pos += 1
					self.setCmdline(self.cmdline)
			
			elif (char == curses.KEY_HOME):
				self.pos = 0
				self.setCmdline(self.cmdline)
			
			elif (char == curses.KEY_END):
				self.pos = len(self.cmdline)
				self.setCmdline(self.cmdline)
			
			elif (char == curses.KEY_NPAGE):
				if (len(self.lines) > self.yMax-2):
					self.linesBack -= 5
					if (self.linesBack < 0):
						self.linesBack = 0
					#logger.debug("linesBack: %s" % self.linesBack)
					self.display()
				
			
			elif (char == curses.KEY_PPAGE):
				if (len(self.lines) > self.yMax-2):
					self.linesBack += 5
					if (self.linesBack > len(self.lines)-self.yMax+2):
						self.linesBack = len(self.lines)-self.yMax+2
					#logger.debug("linesBack: %s" % self.linesBack)
					self.display()
			
			elif (char == 4):
				# ^D
				self.exit()
			
			elif (char == 10):
				# Enter
				self.pos = len(self.cmdline)
				self.setCmdline(self.cmdline)
			
			elif (char == 18):
				# ^R
				if (self.reverseSearch == None):
					self.setInfoline("reverse-i-search")
					self.reverseSearch = ''
				else:
					self.setInfoline("")
					self.reverseSearch = None
				continue
				
			elif (char == 9):
				# tab 		|<- ->|
				# Auto-completion
				completions = []
				
				params = self.getParams()
				if (self.paramPos >= 0):
					params[self.paramPos] = self.currentParam
				
				for c in self.commands:
					if (self.paramPos < 0):
						completions.append(c.getName())
					
					elif (params[0] == c.getName()):
						if (self.paramPos >= 1):
							completions = c.completion( params[1:], self.paramPos )
						else:
							completions = [ c.getName() ]
						break
					
					elif c.getName().startswith(params[0]):
						completions.append(c.getName())
				
				#logger.info("completions: %s" % completions)
				
				if (len(completions) == 1):
					self.setCmdline(self.cmdline[:self.pos] + \
							completions[0][len(params[self.paramPos]):] + \
							self.cmdline[self.pos:])
					self.pos += len(completions[0][len(params[self.paramPos]):])
						
					if (self.pos == len(self.cmdline)):
						self.cmdline += ' '
						self.pos += 1
					
					self.setCmdline(self.cmdline)
				
				elif (len(completions) > 1):
					
					match = completions[0]
					lines = []
					longest = 0
					for comp in completions:
						for c in range(len(comp)):
							if ( c > len(match)-1 ):
								break
							elif ( comp[c] != match[c] ):
								match = match[:c]
								break
						if (len(comp) > longest):
							longest = len(comp)
					
					curLine = ''
					i = 0
					while(i < len(completions)):
						while (i < len(completions)) and (not curLine or (len(curLine) + longest < self.xMax - 5)):
							pf = '%s %-' + str(longest) + 's'
							curLine = pf % (curLine, completions[i])
							i+=1
						lines.append( { "text": curLine, "color": None } )
						curLine = ''
					
					if (self.paramPos < 0):
						self.currentParam = ""
					
					self.lines.append( { "text":	self.prompt + ' ' + \
							  		self.cmdline[:self.pos-len(self.currentParam)] + \
									match.strip() + \
									self.cmdline[self.pos:],
							      "color":	None } )
					
					self.lines.extend(lines)
					
					self.setCmdline(self.cmdline[:self.pos-len(self.currentParam)] + \
							 match.strip() + \
							 self.cmdline[self.pos:])
					
					self.pos += len(match)-len(self.currentParam)
					
					self.setCmdline(self.cmdline)
					
				else:
					self.bell()
			
			else:
				textInput = True
				newPos = self.pos
				newCmdline = self.cmdline
				
				if (char == 263):
					# backspace	<--
					if (self.reverseSearch != None):
						self.reverseSearch = self.reverseSearch[:-1]
						self.setInfoline('reverse-i-search: %s' % self.reverseSearch)
					elif (self.pos > 0):
						newPos = self.pos - 1
						newCmdline = self.cmdline[:newPos] + self.cmdline[self.pos:]
				elif (char == 330):
					# del
					if (self.reverseSearch != None):
						pass
					elif (len(self.cmdline) > 0):
						newCmdline = self.cmdline[:self.pos] + self.cmdline[self.pos+1:]
			
				else:
					try:
						if (self.reverseSearch != None):
							self.reverseSearch += chr(char)
						else:
							newPos = self.pos + 1
							newCmdline = self.cmdline[0:self.pos] + chr(char) + self.cmdline[self.pos:]
					except Exception, e:
						logger.error("Failed to add char '%s': %s" % (char, e))
				try:
					if (self.reverseSearch != None):
						self.setInfoline('reverse-i-search: %s' % self.reverseSearch)
						found = False
						for i in range(len(self.cmdList)-1, -1, -1):
							if (self.cmdList[i].find(self.reverseSearch) != -1):
								found = True
								newCmdline = self.cmdList[i]
								break
						if not found and char not in [263, 330]:
							self.bell()
						newPos = len(newCmdline)
					
					self.pos = newPos
					self.setCmdline(newCmdline)
				except Exception, e:
					self.setInfoline(str(e))
					pass
				
			if not textInput:
				if (self.reverseSearch != None):
					self.reverseSearch = None
					self.setInfoline("")
				
		self.cmdline = self.cmdline.strip()
		
		self.appendLine(self.prompt + ' ' + self.cmdline)
		if self.cmdline:
			try:
				self.execute()
			except Exception, e:
				try:
					self.execute()
				except Exception, e:
					lines = str(e).split('\n')
					lines[0] = "ERROR: %s" % lines[0]
					for line in lines:
						self.appendLine(line, COLOR_RED)
				
		if (len(self.lines) > self.yMax-2):
			self.linesBack = 0
			#logger.debug("linesBack: %s" % self.linesBack)
		
class Command:
	def __init__(self, name):
		self.name = name
	def getName(self):
		return self.name
	def getDescription(self):
		return ""
	def completion(self, params, paramPos):
		return []
	def help(self, shell):
		shell.appendLine("")
	def execute(self, shell, params):
		raise NotImplementedError("Nothing to do.")
	
	
class CommandMethod(Command):
	from OPSI import Tools
	
	def __init__(self):
		Command.__init__(self, 'method')
	
	def getDescription(self):
		return _("Execute a config-interface-method")
	
	def help(self, shell):
		shell.appendLine(_("\rMethods are:\n"))
		for m in backend.getPossibleMethods_listOfHashes():
			logger.debug(m)
			shell.appendLine("\r%s\n" % m.get('name'))
	
	def completion(self, params, paramPos):
		completions = []
		
		if ( paramPos == 0 ):
			completions.append('list')
			for m in backend.getPossibleMethods_listOfHashes():
				completions.append( m.get('name') )
			
		elif ( paramPos == 1):
			method = None
			if 'list'.startswith( params[0] ):
				completions.append('list')	
			for m in backend.getPossibleMethods_listOfHashes():
				if m.get('name').startswith( params[0] ):
					completions.append( m.get('name') )
		
		elif ( paramPos >=2 ):
			for m in backend.getPossibleMethods_listOfHashes():
				if (m.get('name') == params[0]):
					if ( len(m.get('params')) >= len(params)-1 ):
						completions = [ m.get('params')[paramPos-2] ]
					break
		
		return completions
		
	def execute(self, shell, params):
		if (len(params) <= 0):
			shell.appendLine( _('No method defined') )
			return
		method = params[0]
		
		if (method == 'list'):
			for m in backend.getPossibleMethods_listOfHashes():
				shell.appendLine("%s(%s)" % (m.get('name'), str(m.get('params'))[1:-1]), refresh=False )
			shell.display()
			return
		
		params = params[1:]
		result = None
		
		#logger.debug("params: %s" % params)
		for i in range(len(params)):
			if (len(params[i].strip()) == 0):
				params[i] = 'null'
			elif ( params[i] == 'null' ):
				pass
			elif ( params[i].strip()[0] not in ('{', '[', '"') ):
				params[i] = '"%s"' % params[i]
			params[i] = json.read(params[i])
			#logger.debug( "Type of param: %s" % type(params[i]) )
		
		#if (len(params) == 1) and (isinstance(params[0], list) or isinstance(params[0], tuple)):
		#	params[i] = [ params[i] ]
		
		# Check if possible method
		valid = False
		for f in backend.getPossibleMethods_listOfHashes():
			if (f['name'] == method):
				valid = True
		
		if not valid:
			raise Exception("Method '%s' is not valid" % method)
		
		logger.info( "Executing:  %s(%s)" % (method, str(params)[1:-1]) )
		shell.setInfoline( "Executing:  %s(%s)" % (method, str(params)[1:-1]) )
		start = time.time()
		result = eval( "backend.%s(%s)" % (method, str(params)[1:-1]) )
		duration = round(time.time() - start, 3)
		logger.debug('Took %0.3fs to process %s(%s)' % (duration, method, str(params)[1:-1]))
		shell.setInfoline( _('Took %0.3fs to process %s(%s)') % (duration, method, str(params)[1:-1]) )
		
		if result:
			lines = []
			if (shell.output == 'NICE'):
				lines = Tools.jsonObjToBeautifiedText(result, 0).split('\n')
					
			elif (shell.output == 'SHELL'):
				bashVars = Tools.jsonObjToBash(result, {})
				for i in range(len(bashVars)-1, -2, -1):
					if (i == -1): i = ''
					v = bashVars.get('RESULT%s' % i)
					if v:
						lines.append('RESULT%s=%s' % (i, v))
						
			elif (shell.output == 'SIMPLE'):
				if (type(result) == type({})):
					raise Exception("Simple output not possible for dicts")
				
				if (type(result) == type([]) or type(result) == type(())):
					for r in result:
						if (type(r) == type({})):
							raise Exception("Simple output not possible for list of dicts")
						if (type(r) == type([]) or type(r) == type(())):
							raise Exception("Simple output not possible for list of lists")
						lines.append( str(r) )
				else:
					lines.append( str(result) )
			else:
				lines.append( str(result) )
			
			if shell.shellCommand:
				
				logger.notice("Executing: '%s'" % shell.shellCommand)
				
				fi = popen2.Popen3(shell.shellCommand, capturestderr = True)
				
				exitCode = -1
				
				buf = ''
				err = ''
				
				while (exitCode == -1):
					if lines:
						try:
							for line in lines:
								print >> fi.tochild, line
							lines = []
							if not fi.tochild.closed:
								fi.tochild.close()
						except Exception, e:
							logger.warning(e)
					
					try:
						string = fi.fromchild.read()
						if (len(string) > 0):
							buf += string
					except OSError:
						pass
					
					try:
						string = fi.childerr.read()
						if (len(string) > 0):
							err += string
					except OSError:
						pass
					
					exitCode = fi.poll()
					
				
				if (exitCode != 0):
					raise Exception('\n' + err)
					
				lines = buf.split('\n')
				
				
			for line in lines:
				shell.appendLine( line, COLOR_GREEN )

class CommandSet(Command):
	def __init__(self):
		Command.__init__(self, 'set')
	
	def getDescription(self):
		return _("Settings")
	
	def completion(self, params, paramPos):
		completions = []
		
		if ( paramPos == 0 or not params[0] ):
			completions = ['color', 'log-file', 'log-level']
		
		elif ( paramPos == 1 ):
			if 'color'.startswith(params[0]):
				completions = ['color']
			if 'log-file'.startswith(params[0]):
				completions = ['log-file']
			if 'log-level'.startswith(params[0]):
				completions.append('log-level')
		
		elif ( paramPos == 2 ):
			if (params[0] == 'color'):
				completions = ['on', 'off']
			
			elif (params[0] == 'log-file'):
				completions = ['<filename>', 'off']
			elif (params[0] == 'log-level'):
				completions = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
		
		return completions
	
	def execute(self, shell, params):
		global logFile
		global logLevel
		
		if (len(params) <= 0):
			raise Exception(_('Missing option'))
		if(params[0] not in ['color', 'log-file', 'log-level']):
			raise Exception(_('Unknown option: %s') % params[0])
		if (len(params) <= 1):
			raise Exception(_('Missing value'))
		
		if (params[0] == 'color'):
			if (params[1] == 'on'):
				shell.setColor(True)
			elif  (params[1] == 'off'):
				shell.setColor(False)
			else:
				raise Exception(_('Bad value: %s') % params[1])
		
		elif (params[0] == 'log-file'):
			if (params[1] == 'off'):
				#logFile = None
				logger.setFileLevel(LOG_NONE)
				logger.setLogFile(None)
			else:
				logFile = params[1]
				f = open(logFile, 'w')
				print >> f, "Starting log at: %s" % time.strftime("%a, %d %b %Y %H:%M:%S")
				f.close()
				logger.setLogFile(logFile)
				logger.setFileLevel(logLevel)
			
		elif (params[0] == 'log-level'):
			if not logFile:
				raise Exception(_('No log-file set!'))
			logger.setFileLevel(int(params[1]))
			
			
class CommandHelp(Command):
	def __init__(self):
		Command.__init__(self, 'help')
	
	def getDescription(self):
		return _("Show this text")
	
	def execute(self, shell, params):
		shell.appendLine( _("\rCommands are:\n"), refresh = False )
		for cmd in shell.commands:
			shell.appendLine( "\r\t%-20s%s\n" % (cmd.getName() + ':', cmd.getDescription()), refresh = False )
		shell.display()


class CommandQuit(Command):
	def __init__(self):
		Command.__init__(self, 'quit')
	
	def getDescription(self):
		return _("Exit opsi-admin")
	
	def execute(self, shell, params):
		try:
			shell.exit()
		except SystemExit:
			pass

class CommandExit(CommandQuit):
	def __init__(self):
		Command.__init__(self, 'exit')
	
class CommandHistory(Command):
	def __init__(self):
		Command.__init__(self, 'history')
	
	def getDescription(self):
		return _("show / clear command history")
	
	def completion(self, params, paramPos):
		completions = []
		
		if ( paramPos == 0 or not params[0] ):
			completions = ['clear', 'show']
		
		elif ( paramPos == 1 ):
			if 'clear'.startswith(params[0]):
				completions = ['clear']
			elif 'show'.startswith(params[0]):
				completions = ['show']
		
		return completions
		
	def execute(self, shell, params):
		if (len(params) <= 0):
			# By default: show history
			params = ['show']
		elif(params[0] not in ('clear', 'show')):
			raise Exception(_('unknown command: %s') % params[0])
			
		if (params[0] == 'show'):
			for line in shell.cmdList:
				shell.appendLine(line, refresh=False)
			shell.display()
		elif (params[0] == 'clear'):
			shell.cmdList = []
			shell.cmdListPos = -1


class CommandLog(Command):
	def __init__(self):
		Command.__init__(self, 'log')
	
	def getDescription(self):
		return _("show log")
	
	def completion(self, params, paramPos):
		completions = []
		
		if ( paramPos == 0 or not params[0] ):
			completions = ['show']
		
		elif ( paramPos == 1 ):
			if 'show'.startswith(params[0]):
				completions = ['show']
		
		return completions
		
	def execute(self, shell, params):
		if (len(params) <= 0):
			# By default: show log
			params = ['show']
		elif(params[0] not in ('show')):
			raise Exception(_('unknown command: %s') % params[0])
			
		if (params[0] == 'show'):
			if not logFile:
				raise Exception(_('File logging is not activated'))
			
			f = open(logFile)
			for line in f.readlines():
				shell.appendLine(line, refresh=False)
			shell.display()
			f.close()


class CommandTask(Command):
	def __init__(self):
		Command.__init__(self, 'task')
		self._tasks = (
			('setupWhereInstalled', 'productId'),
			('updateWhereInstalled', 'productId'),
			('decodePcpatchPassword', 'encodedPassword', 'opsiHostKey'),
			('setPcpatchPassword', '*password')
		)
	
	def getDescription(self):
		return _("execute a task")
	
	def help(self, shell):
		shell.appendLine('')
	
	def completion(self, params, paramPos):
		completions = []
		
		if (paramPos == 0) or not params[0]:
			for task in self._tasks:
				completions.append(task[0])
		
		elif ( paramPos == 1 ):
			for task in self._tasks:
				if task[0].startswith(params[0]):
					completions.append(task[0])
		
		elif ( paramPos >= 2):
			for task in self._tasks:
				if (params[0] == task[0]) and (paramPos <= len(task)):
					completions.append(task[paramPos-1])
		
		return completions
		
	def execute(self, shell, params):
		if (len(params) <= 0):
			return
		
		elif(params[0] not in ('setupWhereInstalled', 'updateWhereInstalled', 'decodePcpatchPassword', 'setPcpatchPassword')):
			raise Exception(_('Unknown task: %s') % params[0])
		
		if (params[0] == 'setupWhereInstalled'):
			if (len(params) < 2):
				raise Exception(_('Missing product-id'))
			productId = params[1]
			clientIds = backend.getClientIds_list(productId = productId, installationStatus = 'installed')
			#clientIds = backend.getClientIds_list('', '', productId, 'installed')
			if clientIds:
				for clientId in clientIds:
					shell.appendLine(clientId)
					backend.setProductActionRequest(productId, clientId, 'setup')
		
		if (params[0] == 'updateWhereInstalled'):
			if (len(params) < 2):
				raise Exception(_('Missing product-id'))
			productId = params[1]
			clientIds = backend.getClientIds_list(productId = productId, installationStatus = 'installed')
			#clientIds = backend.getClientIds_list('', '', productId, 'installed')
			if clientIds:
				for clientId in clientIds:
					shell.appendLine(clientId)
					backend.setProductActionRequest(productId, clientId, 'update')
		
		if (params[0] == 'decodePcpatchPassword'):
			if (len(params) < 3):
				raise Exception(_('Missing argument'))
			crypt = params[1]
			key = params[2]
			cleartext = blowfishDecrypt(key, crypt)
			shell.appendLine(cleartext)
		
		if (params[0] == 'setPcpatchPassword'):
			if (os.getuid() != 0):
				raise Exception(_("You have to be root to change pcpatch password!"))
			
			fqdn = ''
			(name, aliaslist, addresslist) = socket.gethostbyname_ex(socket.gethostname())
			if ( len(name.split('.')) > 1 ):
				fqdn = name
			else:
				raise Exception("Failed to get my own fully qualified domainname")
			
			password = ''
			if (len(params) < 2):
				password = shell.getPassword()
			else:
				password = params[1]
			
			backend.setPcpatchPassword(fqdn, blowfishEncrypt(backend.getOpsiHostKey(fqdn), password))
			
			f = os.popen(which('chpasswd'), 'w')
			f.write("pcpatch:%s\n" % password)
			f.close()
			
			f = os.popen('%s -a -s pcpatch 1>/dev/null 2>/dev/null' % which('smbpasswd'), 'w')
			f.write("%s\n%s\n" % (password, password))
			f.close()
			
			for clientId in backend.getClientIds_list(serverId = fqdn):
				try:
					clientKey = backend.getOpsiHostKey(clientId)
					backend.setPcpatchPassword( clientId, blowfishEncrypt(clientKey, password) )
				except Exception, e:
					logger.warning("Failed to update password for client '%s': %s" % (clientId, e))
					shell.appendLine("WARNING: Failed to update password for client '%s': %s" % (clientId, e), COLOR_YELLOW)
			
		
if (__name__ == "__main__"):
	exception = None
	
	try:
		if (os.name == 'posix'):
			from signal import *
			signal(SIGINT, signalHandler)
			signal(SIGQUIT, signalHandler)
		
		main(sys.argv[1:])
		
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if shell:
		try:
			shell.exit()
		except:
			pass
		
	if exception:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(exception)
		print >> sys.stderr, "ERROR:", str(exception)
		sys.exit(1)
	
	sys.exit(0)
	
	

