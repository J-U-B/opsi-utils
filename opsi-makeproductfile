#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = =
   =   opsi-makeproductfile    =
   = = = = = = = = = = = = = = =
   
   opsi-makeproductfile is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2010 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '4.0'

import sys, os, getopt, gettext, re, tty, termios

# OPSI imports
from OPSI.Logger import *
from OPSI.System import *
from OPSI.Types import *
from OPSI.Util.Message import ProgressObserver, ProgressSubject
from OPSI.Util.Product import *
from OPSI.Util.File.Opsi import PackageControlFile
from OPSI.Util import md5sum

# Get logger instance
logger = Logger()

# Get locale
try:
	t = gettext.translation('opsi_makeproductfile', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string
	
def usage():
	print u"\nUsage: %s [-h] [-v|-q] [-F format] [-l log-level] [-i|-c custom name] [-I required version] [-t temp dir] [source directory]" % os.path.basename(sys.argv[0])
	print u"Provides an opsi package from a package source directory."
	print u"If no source directory is supplied, the current directory will be used."
	print u"Options:"
	print u"   -v          verbose"
	print u"   -q          quiet"
	print u"   -l          log-level 0..9"
	print u"   -n          do not compress"
	print u"   -F          archive format [tar|cpio], default: cpio"
	print u"   -h          follow symlinks"
	print u"   -I          incremental package"
	print u"   -i          custom name (add custom files)"
	print u"   -c          custom name (custom only)"
	print u"   -C          compatibility mode (opsi 3)"
	print u"   -t          temp dir"
	print u""


class ProgressNotifier(ProgressObserver):
	def __init__(self):
		self.usedWidth = 60
		try:
			tty = os.popen('tty').readline().strip()
			fd = open(tty)
			terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
			if (self.usedWidth > terminalWidth):
				self.usedWidth = terminalWidth
			fd.close()
		except:
			pass
		
	def progressChanged(self, subject, state, percent, timeSpend, timeLeft, speed):
		if (subject.getEnd() <= 0):
			return
		barlen = self.usedWidth - 10
		filledlen = int("%0.0f" % (barlen*percent/100))
		bar = u'='*filledlen + u' '*(barlen-filledlen)
		percent = '%0.2f%%' % percent
		sys.stderr.write('\r %8s [%s]\r' % (percent, bar))
		sys.stderr.flush()
		
	def messageChanged(self, subject, message):
		sys.stderr.write('\n%s\n' % message)
		sys.stderr.flush()

def lockPackage(tempDir, packageControlFile):
	lockFile = os.path.join(tempDir, u'.opsi-makeproductfile.lock.%s' % packageControlFile.getProduct().id)
	# Test if other processes are accessing same product
	try:
		lf = open(lockFile, 'r')
		p = lf.read().strip()
		lf.close()
		
		if p:
			for line in execute(u"ps -A"):
				line = line.strip()
				if not line:
					continue
				if (p == line.split()[0].strip()):
					pName = line.split()[-1].strip()
					# process is running
					raise Exception(u"Product '%s' is currently locked by process %s (%s)." \
								% (packageControlFile.getProduct().id, pName, p) )
	
	except IOError:
		pass
	
	# Write lock-file
	lf = open(lockFile, 'w')
	lf.write(str(os.getpid()))
	lf.close()
	
def unlockPackage(tempDir, packageControlFile):
	lockFile = os.path.join(tempDir, u'.opsi-makeproductfile.lock.%s' % packageControlFile.getProduct().id)
	if os.path.isfile(lockFile):
		os.unlink(lockFile)

def main(argv):
	os.umask(022)
	
	logLevel          = LOG_WARNING
	packageSourceDir  = os.getcwd()
	tempDir           = u'/tmp'
	lockFile          = None
	customName        = u''
	customOnly        = False
	quiet             = False
	format            = 'cpio'
	compression       = 'gzip'
	dereference       = False
	requiredVersion   = None
	incremental       = False
	compatibilityMode = False
	
	logger.setConsoleLevel(logLevel)
	logger.setConsoleColor(True)
	logger.setConsoleFormat(u'%L: %M')
	
	try:
		(opts, args) = getopt.getopt(argv, "Chvnqi:c:t:l:F:I:")
	
	except getopt.GetoptError:
		usage()
		sys.exit(1)
	
	for (opt, arg) in opts:
		if   (opt == "-h"):
			dereference = True
		elif (opt == "-v"):
			logLevel = LOG_DEBUG
			logger.setColor(True)
		elif (opt == "-l"):
			logLevel = forceInt(arg)
			logger.setColor(True)
		elif (opt == "-n"):
			compression = None
		elif (opt == "-q"):
			logLevel = LOG_NONE
			quiet = True
		elif (opt == "-i"):
			customName = arg
		elif (opt == "-c"):
			customName = arg
			customOnly = True
		elif (opt == "-I"):
			requiredVersion = arg
			incremental = True
		elif (opt == "-t"):
			tempDir = forceFilename(arg)
		elif (opt == "-F"):
			format = forceUnicode(arg)
		elif (opt == "-C"):
			compatibilityMode = True
		
	if (len(args) > 1):
		logger.error(u"To many arguments")
		usage()
		sys.exit(1)
	
	elif (len(args) > 0):
		packageSourceDir = os.path.abspath( args[0] )
	
	logger.setConsoleLevel(logLevel)
	
	logger.info(u"Source dir: %s" % packageSourceDir)
	logger.info(u"Temp dir: %s" % tempDir)
	logger.info(u"Custom name: %s" % customName)
	logger.info(u"Archive format: %s" % format)
	
	if format not in ['tar', 'cpio']:
		raise Exception(u"Unsupported archive format: %s" % format)
	
	if not os.path.isdir(packageSourceDir):
		raise Exception(u"No such directory: %s" % packageSourceDir)
	
	if customName:
		packageControlFilePath = os.path.join(packageSourceDir, u'OPSI.%s' % customName, u'control')
	if not customName or not os.path.exists(packageControlFilePath):
		packageControlFilePath = os.path.join(packageSourceDir, u'OPSI', u'control')
		if not os.path.exists(packageControlFilePath):
			raise Exception(u"Control file '%s' not found" % packageControlFilePath)
	
	if not quiet: print ""
	if not quiet: print _(u"Locking package")
	pcf = PackageControlFile(packageControlFilePath, opsi3compatible = compatibilityMode)
	
	lockPackage(tempDir, pcf)
	pps = None
	try:
		while True:
			product = pcf.getProduct()
			if incremental:
				match = re.search('^\s*([<>]?=?)(^[<>=]+)\s*$', requiredVersion)
				if not match:
					raise Exception(u"Bad version string '%s' in dependency" % requiredVersion)
				packageDependency = { 'package': product.id, 'condition': match.group(1), 'version': match.group(2) }
				pcf.setPackageDependencies([ packageDependency ])
				pcf.setIncrementalPackage(True)
			
			if not quiet: print u""
			if not quiet: print _(u"Package info")
			if not quiet: print u"----------------------------------------------------------------------------"
			if not quiet: print u"   %-20s : %s" % (u'version',             product.packageVersion)
			if not quiet: print u"   %-20s : %s" % (u'custom package name', customName)
			if not quiet: print u"   %-20s : %s" % (u'incremental package', incremental)
			if not quiet:
				dependencies = []
				for dep in pcf.getPackageDependencies():
					dependencies.append(u'%s(%s%s)' % (dep['package'], dep['condition'], dep['version']))
				print       u"   %-20s : %s" % (u'package dependencies', u', '.join(dependencies))
			
			if not quiet: print ""
			if not quiet: print _(u"Product info")
			if not quiet: print u"----------------------------------------------------------------------------"
			if not quiet: print u"   %-20s : %s" % (u'product id',           product.id)
			if not quiet and (product.getType() == 'LocalbootProduct'):
				print       u"   %-20s : %s" % (u'product type',         u'localboot')
			if not quiet and (product.getType() == 'NetbootProduct'):
				print       u"   %-20s : %s" % (u'product type',         u'netboot')
			if not quiet: print u"   %-20s : %s" % (u'version',              product.productVersion)
			if not quiet: print u"   %-20s : %s" % (u'name',                 product.name)
			if not quiet: print u"   %-20s : %s" % (u'description',          product.description)
			if not quiet: print u"   %-20s : %s" % (u'advice',               product.advice)
			if not quiet: print u"   %-20s : %s" % (u'priority',             product.priority)
			if not quiet: print u"   %-20s : %s" % (u'licenseRequired',      product.licenseRequired)
			if not quiet: print u"   %-20s : %s" % (u'product classes',      u', '.join(product.productClassIds))
			if not quiet: print u"   %-20s : %s" % (u'windows software ids', u', '.join(product.windowsSoftwareIds))
			if not quiet and (product.getType() == 'NetbootProduct'):
				print       u"   %-20s : %s" % (u'pxe config template',  product.pxeConfigTemplate)
			
			if not quiet: print ""
			if not quiet: print _(u"Product scripts")
			if not quiet: print u"----------------------------------------------------------------------------"
			if not quiet: print u"   %-20s : %s" % (u'setup',      product.setupScript)
			if not quiet: print u"   %-20s : %s" % (u'uninstall',  product.uninstallScript)
			if not quiet: print u"   %-20s : %s" % (u'update',     product.updateScript)
			if not quiet: print u"   %-20s : %s" % (u'always',     product.alwaysScript)
			if not quiet: print u"   %-20s : %s" % (u'once',       product.onceScript)
			if not quiet: print u"   %-20s : %s" % (u'custom',     product.customScript)
			if not quiet and (product.getType() == 'LocalbootProduct'):
				print       u"   %-20s : %s" % (u'user login', product.userLoginScript)
			if not quiet: print u""
			
			pps = ProductPackageSource(
				packageSourceDir   = packageSourceDir,
				tempDir            = tempDir,
				customName         = customName,
				customOnly         = customOnly,
				packageFileDestDir = os.getcwd(),
				format             = format,
				compression        = compression,
				dereference        = dereference)
			
			if not quiet and os.path.exists(pps.getPackageFile()):
				print _(u"Package file '%s' already exists." % pps.getPackageFile())
				print _(u"Press <O> to overwrite, <C> to abort or <N> to specify a new version:"),
				newVersion = False
				fd = sys.stdin.fileno()
				savedSettings = termios.tcgetattr(fd)
				tty.setraw(fd)
				try:
					while True:
						ch = sys.stdin.read(1)
						if   ch in ('o', 'O'):
							break
						elif ch in ('c', 'C'):
							raise Exception(_(u"Aborted"))
						elif ch in ('n', 'N'):
							newVersion = True
							break
				finally:
					termios.tcsetattr(fd, termios.TCSADRAIN, savedSettings)
					print '\r\033[0K'
				
				if newVersion:
					while True:
						print '\r%s' % _(u"Please specify new product version, press <ENTER> to keep current version (%s):") % product.productVersion,
						newVersion = sys.stdin.readline().strip()
						try:
							if (newVersion != ''):
								product.setProductVersion(newVersion)
								pcf.generate()
							break
						except:
							print _(u"Bad product version: %s") % newVersion
					while True:
						print '\r%s' % _(u"Please specify new package version, press <ENTER> to keep current version (%s):") % product.packageVersion,
						newVersion = sys.stdin.readline().strip()
						try:
							if (newVersion != ''):
								product.setPackageVersion(newVersion)
								pcf.generate()
							break
						except:
							print _(u"Bad package version: %s") % newVersion
					continue
			
			# Regenerating to fix encoding
			pcf.generate()
			
			progressSubject = None
			if not quiet:
				progressSubject = ProgressSubject('packing')
				progressSubject.attachObserver(ProgressNotifier())
				print _(u"Creating package file '%s'" % pps.getPackageFile())
			pps.pack(progressSubject = progressSubject)
			
			if not quiet: print "\n"
			if not quiet: print _(u"Creating md5sum file '%s.md5'" % pps.getPackageFile())
			md5 = md5sum(pps.packageFile)
			f = open(pps.packageFile + u'.md5', 'w')
			f.write(md5)
			f.close()
			break
	finally:
		if pps:
			if not quiet: print _(u"Cleaning up")
			pps.cleanup()
		if not quiet: print _(u"Unlocking package")
		unlockPackage(tempDir, pcf)
		if not quiet: print ""
	
if (__name__ == "__main__"):
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(exception)
		print >> sys.stderr, u"ERROR: %s" % exception
		sys.exit(1)
	
	sys.exit(0)



