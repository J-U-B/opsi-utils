#!/bin/bash
# fuer Linux: #!/bin/bash
# Allgemeines Skrip zur Erstellung von Produkt-Installations-Dateien
# 26.6.97  weick, oertel (c) uib & HMUEJFG
# 02.04.02  neuere Version mit fileinstall
#   Kristian

LC_ALL=C
LANG=C
PATH=/bin:/usr/bin:/sbin:/usr/sbin:/opt/bin:/usr/ucb:/usr/ccs/bin
export LANG PATH LC_ALL

# Erstelle AWK Variable mit dem "richtigen" awk Programm
if [ -x "`which gawk`" ] ; then AWK=gawk
   else if [ -x "`which nawk`" ] ; then AWK=nawk
      else AWK=awk
   fi
fi
# Erstelle CPIO Variable mit dem "richtigen" cpio Programm
if [ -x "`which gnucpio`" ] ; then CPIO=gnucpio
    else CPIO=cpio
fi

# Defaultwerte
# VERBOSE=""|v
VERBOSE=""
# COMPRESS=on|off
COMPRESS=on
# TESTAKTUAL=on|of
TESTAKTUAL=on
custom_name=_____

MYNAME=`basename $0`
WD=`pwd`
PRODHOME=/home/root/BK-ServerInstallation


while [ -n "$1" ] ; do
    case $1 in
       -h*|--h*)  
          echo "Aufruf : $MYNAME -h    gibt Hilfe aus"
          echo "         $MYNAME [-v|-s] [-c|-n] [Produktname]"
          echo "Optionen:  -v          verbose"
          echo "           -s          silent"
          echo "           -c          komprimieren"
          echo "           -n          nicht komprimieren"
          echo "           -f          fast, kein Test auf Aktualitaet"
          echo "           -i <name>   include Dateien zum Kunden <name>"
          echo "Wird Produktname weggelassen, so wird versucht das aktuelle"
          echo "Verzeichnis zu nehmen."
          exit
          ;;
        -v) VERBOSE=v ; shift ;;
        -s) VERBOSE="" ; shift ;;
        -c) COMPRESS=on ; shift ;;
        -n) COMPRESS=off ; shift ;;
	-f) TESTAKTUAL=off ; shift ;;
	-i) shift ; custom_name=$1 ; shift ;;
         *) PRODUCT=$1 ; shift ;;
    esac
done

echo "custom_name = $custom_name"

if [ -z "$PRODUCT" ] ; then 
     PRODUCT=`basename \`pwd\``
fi

if [ ! -d $PRODHOME/$PRODUCT ] ; then
   echo "Produkt $PRODUCT gibt es nicht."
   exit
fi

if [ ! -f $PRODHOME/$PRODUCT/fileinstall.$PRODUCT ] ; then
   echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
   echo "Der Installationscript $PRODHOME/$PRODUCT/fileinstall.$PRODUCT fehlt."
   echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
   exit
fi

# Teste ob nicht schon jemand anderes diese Produkt einpackt.
MYPID=$$
PIDFILE=/tmp/make.$PRODUCT

echo $MYPID>> $PIDFILE
if [ "$MYPID" != `cat $PIDFILE` ] ; then
   grep -v "$MYPID" $PIDFILE > /tmp/makeproduct.$MYPID
   mv /tmp/makeproduct.$MYPID $PIDFILE
   # Nachschauen ob die anderen Prozesse wirklich laufen
   PIDPAT=`cat $PIDFILE | tr ' ' '|'`
   if ps -ef | egrep "$PIDPAT" | grep $0 >/dev/null ; then
      echo "Produkt $PRODUCT wird gerade von einem anderen Prozess verpackt."
      echo "Versuche es spaeter nochmal."
      exit 1
   else
      # Bin der einzige Prozess, andere waren Leichen
      echo $MYPID > $PIDFILE
   fi
fi


FILELIST=${PRODHOME}/${PRODUCT}/${PRODUCT}.filelist
STDMODES=/opt/etc/Standardrechte.conf
export FILELIST STDMODES custom_name

# Erstelle Dateiliste und setze Zugriffsrechte
echo "Erstelle Dateiliste und setze Zugriffsrechte ..."
cd $PRODHOME/$PRODUCT   
echo "tmp/fileinstall.${PRODUCT}" > $FILELIST
find `cat ${PRODUCT}.files` -follow -print | $AWK '
   function inarray(elem, array, nofelem)
   {  for (n=1; n<=nofelem; ++n) if (array[n]==elem) return(n);
        return(0);
   }
   function file_isdir(dateiname)
   {   return(!system(sprintf("test -d \"%s\"", dateiname)));
   }
   function isuns(dateiname)
   {  nopat=split(unser, unserpat, ":");
      for (pat=1; pat<=nopat; ++pat) {
          if (match(dateiname, unserpat[pat])==1) return(pat);
      }
      return(0);
   }
   function file_is_customfile(filename)
   {  
      nopat=split(customfiles, custompat, ":");
      for (pat=1; pat<=nopat; ++pat) {
          if (match(filename, custompat[pat])>0) return(pat);
      }
    return(0);
   }
   function file_is_include_custom(filename)
   {
    return(match(filename, "custom_ins.*"custom_name));
   }

         
   function set_modes(dateiname)
   {   if (stdnum=inarray(dateiname, stddir, nostddirs)) {
          smmod=stdmod[stdnum];
          smuser=stduser[stdnum];
          smgroup=stdgroup[stdnum];
       }
       else {
          if (file_isdir(dateiname)) smmod=dirdefaultmode;
          else smmod=filedefaultmode;
          smuser=defaultuser;
          smgroup=defaultgroup;
       }
       chown=sprintf("xargs chown %s", smuser);
       printf("\"%s\"\n", dateiname) | chown;
       chgrp=sprintf("xargs chgrp %s", smgroup);
       printf("\"%s\"\n", dateiname) | chgrp;
       chmod=sprintf("xargs chmod %s", smmod);
       printf("\"%s\"\n", dateiname) | chmod;
   }
   BEGIN {  
      filelist=ENVIRON["FILELIST"];
      stdmodes=ENVIRON["STDMODES"];
      custom_name=ENVIRON["custom_name"];
      # printf ("custom_name = %s\n", custom_name) > "/dev/stderr";
      defaultuser="root";
      defaultgroup="root";
      # fuer Solaris: defaultgroup="other";
      filedefaultmode="u+rw,go-w,go+r";
      dirdefaultmode="u+rwx,go-w,go+rx";
      unser="tftpboot$:tftpboot[/]:opt$:opt[/]"
      customfiles="custom_ins.*:custom_ins_dir[/]"
      nostddirs=0;
      while ( getline < stdmodes >=1 ) {
          if (substr($1, 1, 1) != "#" ) {
             if (split($0, std, ":") != 4) {
                printf("Ungueltige Zeile in %s\n", stdmodes) > "/dev/stderr";
                printf("   Zeile: %s\n", $0)  > "/dev/stderr" ;
             }
             else {
                stddir[++nostddirs] = substr(std[1],2);
                stdmod[nostddirs] = std[2];
                stduser[nostddirs] = std[3];
                stdgroup[nostddirs] = std[4];
             }
          }
       }
    }
    {  if (index($1, "./") == 1) filename=substr($0,3);  
       else {
          if (index($1, "/") == 1) filename=substr($0,2);        
          else filename=$0;
       }
       set_modes(filename);
       if (!file_isdir(filename) || isuns(filename)) {
        if ((! file_is_customfile(filename)) || file_is_include_custom(filename))
          print filename >> filelist;
        else
          printf("Info: Custom file %s not packed.\n", filename);
        fi
       }
       else 
          printf("Warnung: Verzeichnis %s wird nicht eingepackt.\n", filename);
    }'

if [ ! -d tmp ] ; then mkdir tmp ; fi
if [ -f fileinstall.$PRODUCT ] ; then
   $AWK ' 
      function file_exists(dateiname)
      {   return(!system(sprintf("test -f %s", dateiname)));
      }
      function source_file(dateiname)
      { while (x = getline sf_line < dateiname ) print sf_line;
        close(dateiname);
      }
      BEGIN {
      custom_name=ENVIRON["custom_name"];
      }
      $1=="." {  
          if (file_exists($2)) {
             printf "Fuege Datei %s in fileinstall Skript ein.\n", $2 \
                     >"/dev/stderr"
             source_file($2);
          }
          else 
          {
           if (file_exists($2"."custom_name)) 
           {
            printf ("Fuege Datei %s.%s in fileinstall Skript ein.\n", \
                     $2, custom_name)    >"/dev/stderr"
            source_file($2"."custom_name);
           }
           else
           {
             printf ("Warnung: Datei %s(.%s) existiert nicht.\n", \
                                      $2, custom_name) > "/dev/stderr"
             #print
           }
          }
          next
      }
      {  print }' fileinstall.$PRODUCT > tmp/fileinstall.$PRODUCT
   if [ $? != 0 ] ; then
      echo "FEHLER: kann tmp/fileinstall.$PRODUCT nicht erzeugen."
      exit 1
   fi
   if grep '^[ \t]*UNPACK=[$]CPIO' tmp/fileinstall.$PRODUCT >/dev/null ; then
       EXTENSION=cpio
       HEADER=crc
   else
       echo "Warnung: Das Installationsskript kann offensichtlich
        keine cpio Archive entpacken.
        Daher wird ein tar Archiv erstellt.
        Die Verwendung von tar Archiven in hupsi Produkten ist allerdings
        abgekuendigt. Du solltest daher das Installationsskript entsprechend
        dem softprod-Installationsskript anpassen."
       HEADER=ustar
       EXTENSION=tar
   fi
else
   echo "Warnung: Kein Installationsskript vorhanden."
   echo "         erstelle Miniskript mit Meldung, dass es fehlt."
   echo "Kein Installationsskript vorhanden." > tmp/fileinstall.$PRODUCT
fi

      
if [ "$TESTAKTUAL" = on ] ; then
  # Teste Aktualitaet des Pakets
  echo "Teste Aktualitaet des Pakets ..."
  cat $FILELIST | while read fname ; do
      if [ ! -d "$fname" ] ; then
         # fuer Linux
         # if test /$fname -nt $fname ; then
         # fuer Solaris
         if newer "/$fname" "$fname" ; then
             cmp "/$fname" "$fname" || \
                 echo "Warnung: /$fname ist neuer als `pwd`/$fname"
         fi
      fi
  done
fi

#if [ $custom_name != "_____" ] ; then 
# EXTENSION=${custom_name}.${EXTENSION}
#fi

printf  "Erstelle Archiv $PRODUCT.$EXTENSION ..."

chmod +x tmp/fileinstall.$PRODUCT
$CPIO -o${VERBOSE}  -L -H $HEADER -O $PRODUCT.$EXTENSION < $FILELIST 
if [ "$?" != 0 ] ; then
   echo "Fehler beim Erzeugen des Archivs."
   echo "$0 $* abgebrochen!!!"
#   mv tmp/fileinstall.$PRODUCT fileinstall.$PRODUCT
   exit 1
fi
# mv tmp/fileinstall.$PRODUCT fileinstall.$PRODUCT

if [ "$COMPRESS" = on ] ; then 
   printf "Komprimiere ..."
   if [ -f $PRODUCT.$EXTENSION.gz ] ; then rm $PRODUCT.$EXTENSION.gz ; fi
   gzip $PRODUCT.$EXTENSION
   chmod go-w $PRODUCT.$EXTENSION.gz
   if [ "$EXTENSION" = tar ] ; then
      mv $PRODUCT.tar.gz $PRODUCT.tgz
   else
      if [ -f $PRODUCT.tgz ] ; then rm $PRODUCT.tgz ; fi
   fi
else
   if [ "$EXTENSION" = tar ] ; then
      if [ -f $PRODUCT.tgz ] ; then rm $PRODUCT.tgz ; fi
   else 
      if [ -f $PRODUCT.tar ] ; then rm $PRODUCT.tar ; fi
      if [ -f $PRODUCT.tgz ] ; then rm $PRODUCT.tgz ; fi
      if [ -f $PRODUCT.cpio.gz ] ; then rm $PRODUCT.cpio.gz ; fi
   fi
fi

echo " fertig!"
rm $PIDFILE
