#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = =
   =   opsi-package-manager    =
   = = = = = = = = = = = = = = =
   
   opsi-package-manager is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '1.0.1'

import sys, os, base64, re, stat, socket, threading, time, fcntl, math
from optparse import OptionParser, IndentedHelpFormatter
from twisted.web2 import responsecode
from twisted.web2.dav import davxml
from httplib import HTTPConnection, HTTPSConnection
import urllib

import librsync

from OPSI.Backend.Backend import *
from OPSI.Backend.BackendManager import BackendManager
from OPSI.Backend.JSONRPC import JSONRPCBackend
from OPSI.Logger import *
from OPSI.Product import *
from OPSI import Tools
from OPSI.UI import *

logger = Logger()
logLevel = LOG_NONE
logger.setConsoleLevel(logLevel)
logger.setConsoleColor(True)

opm = None

# Get locale
try:
	t = gettext.translation('opsi_package_manager', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string

class TransferProgress:
	def __init__(self, name, size):
		self.name = name
		if (size < 0): size = 0
		self.size = size
		self.percent = 0
		self.state = 0
		self.timeStarted = long(time.time())
		self.timeSpend = 0
		self.timeLeft = 0
		self.timeFired = 0
		self.bytesPerSecond = 0
		self._listener = []
	
	def setState(self, state):
		if (state < 0): state = 0
		if (state > self.size): state = self.size
		self.state = state
		now = long(time.time())
		if (self.timeFired != now) or (state == self.size):
			if (self.size == 0):
				self.percent = 100
			else:
				self.percent = float(100)*(float(self.state) / float(self.size))
			
			self.timeSpend = now - self.timeStarted
			if self.timeSpend:
				self.bytesPerSecond = int(self.state/self.timeSpend)
				self.timeLeft = ((self.size-self.state)/self.bytesPerSecond)
			
			self.timeFired = now
			self.fireProgressChanged()
	
	def addToState(self, x):
		self.setState(self.state + x)
	
	def addListener(self, listener):
		for l in self._listener:
			if (l == listener):
				return
		self._listener.append(listener)
	
	def removeListener(self, listener):
		n = -1
		for i in range(len(self._listener)):
			if (self._listener[i] == listener):
				n = i
				break
		if (n > -1):
			del self._listener[n]
	
	def fireProgressChanged(self):
		for l in self._listener:
			l.progressChanged(self)
	
	
class TransferProgressListener:
	def __init__(self):
		pass
	
	def progressChanged(self, transfer):
		pass
	
class RepositoryError(Exception):
	ExceptionShortDescription = "Repository error"
	
	def __init__(self, message = None):
		self.message = message
	
	def __str__(self):
		#return "<%s: %s>" % (self.__class__.__name__, self.message)
		return str(self.message)
	
	def complete_message(self):
		if self.message:
			return "%s: %s" % (self.ExceptionShortDescription, self.message)
		else:
			return "%s" % self.ExceptionShortDescription

def getRepository(url, username='', password=''):
	if re.search('^file://', url):
		return FileRepository(url, username, password)
	if re.search('^webdavs*://', url):
		return WebDAVRepository(url, username, password)
	raise RepositoryError("Repository url '%s' not supported" % url)
	
class Repository:
	def __init__(self, url, username='', password=''):
		self._url = url
		self._username = username
		self._password = password
		self._path = ''
		self._maxBandwidth = 0
	
	def _absoluteDestination(self, destination):
		raise RepositoryError("Not implemented")
	
	def setMaxBandwidth(self, maxBandwidth):
		self._maxBandwidth = maxBandwidth
	
	def content(self, destination=''):
		raise RepositoryError("Not implemented")
		
	def upload(self, source, destination):
		raise RepositoryError("Not implemented")
		
	def delete(self, destination):
		raise RepositoryError("Not implemented")
	
	def fileInfo(self, destination):
		raise RepositoryError("Not implemented")
	
class FileRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^file://(/[^/]+.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		self._path = match.group(1)
		self._maxBandwidth = 0
		
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def content(self, destination=''):
		destination = self._absoluteDestination(destination)
		try:
			return os.listdir(destination)
		except:
			raise RepositoryError("Not a directory: '%s'" % destination)
	
	def fileInfo(self, destination):
		destination = self._absoluteDestination(destination)
		info = {}
		try:
			fs = os.stat(destination)
			info['size'] = fs[stat.ST_SIZE]
			return info
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
		
	def upload(self, source, destination, progressListener=None):
		
		destination = self._absoluteDestination(destination)
		
		fs = os.stat(source)
		size = fs[stat.ST_SIZE]
		logger.debug("Length of binary data to upload: %d" % size)
		
		transferProgress = TransferProgress(os.path.basename(source) + ' >> ' + self._path, size)
		if progressListener: transferProgress.addListener(progressListener)
		
		(src, dst) = (None, None)
		try:
			src = open(source, 'rb')
			dst = open(destination, 'wb')
			buf = True
			waitTime = 0.0
			bufferSize = 64*1024
			while(buf):
				t1 = time.time()
				buf = src.read(bufferSize)
				read = len(buf)
				if (read > 0):
					dst.write(buf)
					time.sleep(waitTime)
					t2 = time.time()
					dt = t2-t1
					if self._maxBandwidth and (dt > 0):
						speed = int(read/dt)
						wt = 0
						if (speed > 0) and (speed > self._maxBandwidth):
							wt = ( (float(speed)/float(self._maxBandwidth)) ** (0.1) )
						elif (speed > 0) and (speed < self._maxBandwidth):
							wt = ( (float(self._maxBandwidth)/float(speed)) ** (0.1) )
						if wt:
							while (wt > 1):
								wt -= 1
							if (wt > 0.2):
								wt = 0.2
							if (speed > self._maxBandwidth):
								waitTime += wt
							else:
								waitTime -= wt
							if (waitTime < 0):
								waitTime = 0.00001
					transferProgress.addToState(read)
			src.close()
			dst.close()
		except Exception, e:
			if src: src.close()
			if dst: dst.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
		
	def delete(self, source, destination):
		destination = self._absoluteDestination(destination)
		os.unlink(destination)
	
class WebDAVRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^(webdavs*)://([^:]+:*[^:]+):(\d+)(/.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		
		self._protocol = match.group(1)
		self._host = match.group(2)
		if (self._host.find('@') != -1):
			(username, self._host) = self._host.split('@', 1)
			password = ''
			if (username.find(':') != -1):
				(username, password) = username.split(':', 1)
			if not self._username and username: self._username = username
			if not self._password and password: self._password = password
		self._port = int(match.group(3))
		self._path = match.group(4)
		self._auth = 'Basic '+ base64.encodestring( urllib.unquote(self._username + ':' + self._password) ).strip()
		self._connection = None
		self._cookie = ''
		self._maxBandwidth = 0
		
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def _connect(self):
		logger.debug("WebDAVRepository _connect()")
		if self._protocol.endswith('s'):
			self._connection = HTTPSConnection(self._host, self._port)
		else:
			self._connection = HTTPConnection(self._host, self._port)
		
		self._connection.request("PROPFIND", "/products/", headers = { 'authorization': self._auth, 'depth': '0' })
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to connect to '%s://%s:%s': %s" \
				% (self._protocol, self._host, self._port, response.status))
		# We have to read the response!
		response.read()
		
		# Get cookie from header
		cookie = response.getheader('set-cookie', None)
		if cookie:
			# Store cookie 
			self._cookie = cookie.split(';')[0].strip()
	
	def _getContent(self, destination=''):
		
		content = []
		
		self._connect()
		
		self._connection.putrequest('PROPFIND', destination)
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.putheader('depth', '1')
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to list dir '%s': %s" \
				% (destination, response.status))
		
		msr = davxml.WebDAVDocument.fromString(response.read())
		if not msr.root_element.children[0].childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer).childOfType(davxml.ResourceType).children:
			raise RepositoryError("Not a directory: '%s'" % destination)
		for child in msr.root_element.children[1:]:
			#<prop>
			#	<resourcetype/>
			#	<getetag>W/"1737A0-373-47DFF2F3"</getetag>
			#	<getcontenttype>text/plain</getcontenttype>
			#	<getcontentlength>883</getcontentlength>
			#	<getlastmodified>Tue, 18 Mar 2008 17:50:59 GMT</getlastmodified>
			#	<creationdate>2008-03-18T17:50:59Z</creationdate>
			#	<displayname>connect.vnc</displayname>
			#</prop>
			pContainer = child.childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer)
			info = { 'size': long(0), 'type': 'file' }
			info['name'] = str(pContainer.childOfType(davxml.DisplayName))
			if (str(pContainer.childOfType(davxml.GETContentLength)) != 'None'):
				info['size'] = long( str(pContainer.childOfType(davxml.GETContentLength)) )
			if pContainer.childOfType(davxml.ResourceType).children:
				info['type'] = 'dir'
			
			content.append(info)
		
		return content
	
	def content(self, destination=''):
		result = []
		destination = self._absoluteDestination(destination)
		for c in self._getContent(destination):
			result.append( c['name'] )
		return result
	
	def fileInfo(self, destination):
		info = {}
		try:
			path = self._absoluteDestination('/'.join(destination.split('/')[:-1]))
			name = destination.split('/')[-1]
			for c in self._getContent(path):
				if (c['name'] == name):
					info['size'] = c['size']
					return info
			raise Exception('file not found')
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
	
	
	def upload(self, source, destination, progressListener=None):
		destination = self._absoluteDestination(destination)
		src = None
		size = None
		try:
			fs = os.stat(source)
			size = fs[stat.ST_SIZE]
			logger.debug("Length of binary data to upload: %d" % size)
			
			transferProgress = TransferProgress(os.path.basename(source) + ' >> ' + self._host, size)
			if progressListener: transferProgress.addListener(progressListener)
			
			self._connect()
			
			self._connection.putrequest('PUT', destination)
			
			if self._cookie:
				# Add cookie to header
				self._connection.putheader('cookie', self._cookie)
			self._connection.putheader('authorization', self._auth)
			self._connection.putheader('content-length', size)
			self._connection.endheaders()
			
			src = open(source, 'rb')
			buf = True
			waitTime = 0.0
			bufferSize = 64*1024
			while(buf):
				t1 = time.time()
				buf = src.read(bufferSize)
				read = len(buf)
				if (read > 0):
					self._connection.send(buf)
					time.sleep(waitTime)
					t2 = time.time()
					dt = t2-t1
					if self._maxBandwidth and (dt > 0):
						speed = int(read/dt)
						wt = 0
						if (speed > 0) and (speed > self._maxBandwidth):
							wt = ( (float(speed)/float(self._maxBandwidth)) ** (0.1) )
						elif (speed > 0) and (speed < self._maxBandwidth):
							wt = ( (float(self._maxBandwidth)/float(speed)) ** (0.1) )
						if wt:
							while (wt > 1):
								wt -= 1
							if (wt > 0.2):
								wt = 0.2
							if (speed > self._maxBandwidth):
								waitTime += wt
							else:
								waitTime -= wt
							if (waitTime < 0):
								waitTime = 0.00001
					transferProgress.addToState(read)
			src.close()
			
			response = self._connection.getresponse()
			if (response.status != responsecode.CREATED) and (response.status != responsecode.NO_CONTENT):
				raise Exception(response.status)
			# We have to read the response!
			response.read()
		except Exception, e:
			logger.logException(e)
			if src: src.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
		logger.debug2("WebDAV upload done")
	
	def delete(self, destination):
		self._connect()
		
		destination = self._absoluteDestination(destination)
		
		self._connection.putrequest('DELETE', destination)
		
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.NO_CONTENT):
			raise RepositoryError("Failed to delete '%s': %s" \
				% (destination, response.status))
		# We have to read the response!
		response.read()
	


class Task:
	def __init__(self, name, opsiPackageManager, method, params):
		self.name = name
		self.opsiPackageManager = opsiPackageManager
		self.method = method
		self.params = params
		if not type(self.params) is tuple:
			self.params = ( self.params )
		self.started = False
		self.ended = False
		self.exception = None
	
	def abort(self):
		pass
	
	def isRunning(self):
		return self.started and not self.ended
		
	def start(self):
		logger.debug("Task start()")
		self.started = True
		try:
			logger.debug2("Method: %s" % self.method)
			logger.debug2("Params: %s" % str(self.params))
			self.method( *self.params )
		except Exception, e:
			logger.logException(e)
			self.exception = e
			self.ended = True
			raise
		self.ended = True

class UploadTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)
	
	def start(self):
		while self.opsiPackageManager.maxTransfersReached():
			logger.debug("Maximum number transfers reached, waiting")
			time.sleep(1)
		Task.start(self)
		
class InstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class UninstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class TaskQueue(threading.Thread):
	def __init__(self, name):
		threading.Thread.__init__(self)
		self.name = name
		self.tasks = []
		self.started = False
		self.ended = False
		self.errors = []
		self.currentTaskNumber = -1
	
	def abort(self):
		self.ended = True
		task = self.getCurrentTask()
		if task:
			task.abort()
		
	def getCurrentTask(self):
		if (self.currentTaskNumber < 0):
			return None
		return self.tasks[self.currentTaskNumber]
	
	def run(self):
		self.currentTaskNumber = -1
		if not self.tasks:
			raise Exception("No tasks in queue")
		self.started = True
		logger.debug("TaskQueue '%s' started" % self.name)
		i = 0
		while (i < len(self.tasks)):
			if self.ended:	return
			task = self.tasks[i]
			try:
				logger.debug("Starting task '%s'" % task.name)
				self.currentTaskNumber += 1
				task.start()
				logger.debug("Task '%s' ended" % task.name)
				if (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], UploadTask):
					# Sleeping 3 seconds to provide the opportunity to start other upload tasks
					time.sleep(3)
			except Exception, e:
				logger.error("Task '%s' failed: %s" % (task.name, e))
				self.errors.append(e)
				if (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], InstallTask):
					# Upload task failed => do not execute install task
					logger.notice("Upload task failed, skipping install task")
					i += 1
			i += 1
		self.ended = True
		
		
	def addTask(self, task):
		if not isinstance(task, Task):
			raise ValueError("Task wanted, '%s' passed")
		self.tasks.append(task)

class OpsiPackageManager(TransferProgressListener):
	
	def __init__(self):
		
		TransferProgressListener.__init__(self)
		
		self.productPackageFiles = {}
		self.productPackageMD5Sums = {}
		self.maxTransfers = 0
		self.maxBandwidth = 0
		self.overwriteIfMD5SumDiffers = True
		self.overwriteAlways = False
		self.deltaUpload = False
		self.forceInstall = False
		self.keepDefaultProductProperties = False
		self.deleteFilesOnUninstall = True
		self.setupWhereInstalled = False
		self.updateWhereInstalled = False
		self.quiet = True
		self.taskQueues = []
		self.uiType = 'snack'
		self.ui = None
		self.consoleLevelSaved = LOG_NONE
		logger.info("OpsiPackageManager initiated")
	
	def getConfigBackend(self):
		 return BackendManager(authRequired=False)
		
	def abort(self):
		for tq in self.taskQueues:
			tq.abort()
		self.cleanup()
		sys.exit(0)
	
	def cleanup(self):
		self.exitUi()
		for productPackageFile in self.productPackageFiles.values():
			productPackageFile.cleanup()
		
	def openProductPackageFile(self, packageFile):
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.productPackageFiles[os.path.basename(packageFile)] = ProductPackageFile(packageFile)
	
	def getProductPackageFile(self, packageFile):
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.openProductPackageFile(packageFile)
		return self.productPackageFiles.get(os.path.basename(packageFile))
	
	def getMD5Sum(self, packageFile):
		if not self.productPackageMD5Sums.has_key(os.path.basename(packageFile)):
			self.productPackageMD5Sums[os.path.basename(packageFile)] = Tools.md5sum(packageFile)
		return self.productPackageMD5Sums[os.path.basename(packageFile)]
	
	def getDepotConnection(self, depotId):
		depotKey = self.getConfigBackend().getOpsiHostKey(depotId)
		return JSONRPCBackend( username = depotId, password = depotKey, address = depotId )
	
	def getLocalDepotPath(self, depotId):
		depot = self.getConfigBackend().getDepot_hash(depotId)
		localPath = depot['repositoryLocalUrl']
		if not localPath.startswith('file://'):
			raise Exception("Repository local url '%s' not allowed" % localPath)
		localPath = localPath[7:]
		if localPath.endswith('/'):
			localPath = localPath[:-1]
		return localPath
	
	def getRepositoryRemoteURL(self, depotId):
		depot = self.getConfigBackend().getDepot_hash(depotId)
		return depot['repositoryRemoteUrl']
		
	def getNumberOfTransfers(self):
		transfers = 0
		for tq in self.taskQueues:
			ct = tq.getCurrentTask()
			if ct and isinstance(ct, UploadTask) and ct.isRunning():
				transfers += 1
		logger.debug("%d transfers running" % transfers)
		return transfers
	
	def maxTransfersReached(self):
		if self.maxTransfers and (self.getNumberOfTransfers() >= self.maxTransfers):
			return True
		return False
		
	def getErrors(self):
		errors = {}
		for tq in self.taskQueues:
			if not tq.errors:
				continue
			errors[tq.name] = tq.errors
		return errors
	
	def initUi(self):
		if not self.ui:
			self.consoleLevelSaved = logger.getConsoleLevel()
			logger.setConsoleLevel(LOG_NONE)
			self.ui = UIFactory(self.uiType)
			self.ui.drawRootText(1, 1, _('Open PC ServerIntegration'))
			setUI(self.ui)
	
	def exitUi(self):
		if self.ui:
			self.ui.exit()
			logger.setConsoleLevel(self.consoleLevelSaved)
			
	def productPropertiesDialog(self, packageFiles):
		self.initUi()
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for packageFile in packageFiles:
			productId = self.getProductPackageFile(packageFile).product.productId
			for p in self.getProductPackageFile(packageFile).product.productProperties:
				defaultValue = p.defaultValue
				if (len(p.possibleValues) > 0):
					values = []
					for v in p.possibleValues:
						values.append( { "name": v, "selected": (v == defaultValue) } )
					defaultValue = self.ui.getSelection(values, radio=True,
									title=_("Default value for product '%s', property '%s'") % (productId, p.name), 
									text=p.description)
					if defaultValue != None:
						defaultValue = defaultValue[0]
				else:
					defaultValue = self.ui.getValue(text=p.description, default=defaultValue)
					
				if (defaultValue != None):
					p.defaultValue = defaultValue
		self.exitUi()
	
	def getProductInformations(self, depotIds):
		logger.debug('Getting product informations')
		info = {}
		for depotId in depotIds:
			info[depotId]= {}
			be = self.getDepotConnection(depotId)
			for productId in be.getProductIds_list(objectId = depotId):
				info[depotId][productId]= be.getProduct_hash(productId = productId, depotId = depotId)
		return info
	
	
	def uploadToRepositories(self, packageFiles, depotIds):
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
			
		for depotId in depotIds:
			tq = TaskQueue(name = "Upload of package(s) %s to repository '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				localFile = self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile)
				
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
		
	def installOnDepots(self, packageFiles, depotIds, tempDir=None):
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for depotId in depotIds:
			tq = TaskQueue(name = "Install of package(s) %s on depot '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				localFile = self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile)
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
				tq.addTask(
					InstallTask(
						name = "Install of package '%s' on depot '%s'" % (localFile, depotId),
						opsiPackageManager = self,
						method = self.installPackage,
						params = (localFile, depotId, tempDir)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
	
	def setActionSetupWhereInstalled(self, productId, depotId):
		clientIds = self.getConfigBackend().getClientIds_list(depotId = depotId, productId = productId, installationStatus = 'installed')
		clientIds.sort()
		if not clientIds:
			return
		logger.notice("Setting action 'setup' for product '%s' on client(s): %s" % (productId, ', '.join(clientIds)))
		if not self.quiet:
			print _("Setting action 'setup' for product '%s' on client(s): %s") % (productId, ', '.join(clientIds))
		for clientId in clientIds:
			self.getConfigBackend().setProductActionRequest(productId, clientId, 'setup')
	
	def setActionUpdateWhereInstalled(self, productId, depotId):
		clientIds = self.getConfigBackend().getClientIds_list(depotId = depotId, productId = productId, installationStatus = 'installed')
		clientIds.sort()
		if not clientIds:
			return
		logger.notice("Setting action 'update' for product '%s' on client(s): %s" % (productId, ', '.join(clientIds)))
		if not self.quiet:
			print _("Setting action 'update' for product '%s' on client(s): %s") % (productId, ', '.join(clientIds))
		for clientId in clientIds:
			self.getConfigBackend().setProductActionRequest(productId, clientId, 'update')
	
	def uninstallOnDepots(self, productIds, depotIds):
		for depotId in depotIds:
			tq = TaskQueue(name = "Uninstall of package(s) %s on depot '%s'" % (', '.join(productIds), depotId))
			for productId in productIds:
				tq.addTask(
					UninstallTask(
						name = "Uninstall of package '%s' on depot '%s'" % (productId, depotId),
						opsiPackageManager = self,
						method = self.uninstallPackage,
						params = (productId, depotId)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
	
	def extractPackage(self, packageFile, destination):
		self.getProductPackageFile(packageFile).unpackSource(destination)
		
	def uploadToRepository(self, packageFile, depotId):
		logger.notice("Processing upload of '%s' to depot '%s'" \
				% (os.path.basename(packageFile), depotId))
		if not self.quiet: print _("Processing upload of '%s' to depot '%s'") \
						% (os.path.basename(packageFile), depotId)
		
		packageSize = os.stat(packageFile)[stat.ST_SIZE]
		lMD5 = self.getMD5Sum(packageFile)
		destination = os.path.basename(packageFile)
		
		productId = self.getProductPackageFile(packageFile).product.productId
		
		repositoryUrl = self.getRepositoryRemoteURL(depotId)
		logger.info("Using '%s' as repository url" % repositoryUrl)
		
		repository = getRepository(repositoryUrl, depotId, self.getConfigBackend().getOpsiHostKey(depotId))
		repository.setMaxBandwidth(self.maxBandwidth)
		
		if destination in repository.content():
			logger.info("Destination '%s' already exists on depot '%s'" % (destination, depotId))
			if not self.overwriteAlways:
				# Not overwriting always
				if not self.overwriteIfMD5SumDiffers:
					# Do not check md5sum => do not overwrite
					return
				# Checking file sizes first
				if ( repository.fileInfo(destination)['size'] != packageSize ):
					# Size differs => overwrite
					logger.info("Size of source and destination differs on depot '%s'" % depotId)
				else:
					# Sizes match => check md5sum
					logger.info("Size of source and destination matches on depot '%s'" % depotId)
					be = self.getDepotConnection(depotId)
					rMD5 = be.getMD5Sum( self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile) )
					be.exit()
					if (lMD5 == rMD5):
						# md5sum match => do not overwrite
						logger.info("MD5sum of source and destination matches on depot '%s'" % depotId)
						return
					# md5sums differ => overwrite
					logger.info("MD5sum of source and destination differs on depot '%s'" % depotId)
					
			logger.info("Overwriting destination '%s' on depot '%s'" % (destination, depotId))
			if not self.quiet: print _("Overwriting destination '%s' on depot '%s'") % (destination, depotId)
		
		be = self.getDepotConnection(depotId)
		info = be.getDiskSpaceUsage( self.getLocalDepotPath(depotId) )
		be.exit()
		if (info['available'] < packageSize):
			raise Exception("Not enough disk space on depot '%s': %dMB needed, %dMB available" \
						% (depotId, (packageSize/(1024*1024)), (info['available']/(1024*1024))))
		
		oldPackages = []
		for dest in repository.content():
			if dest.startswith(productId + '_') and (dest != destination):
				# same product, different version
				oldPackages.append(dest)
		
		if self.deltaUpload and oldPackages:
			oldPackage = oldPackages[0]
			be = self.getDepotConnection(depotId)
			lp = self.getLocalDepotPath(depotId)
			
			logger.notice("Getting librsync signature of '%s'" % oldPackage)
			if not self.quiet: print "  ", _("Getting librsync signature of '%s'") % oldPackage
			
			sig = base64.decodestring( be.librsyncSignature(lp + '/' + oldPackage) )
			
			logger.notice("Calculating delta")
			if not self.quiet: print "  ", _("Calculating delta")
			
			deltaFileName = '%s_%s.delta' % (productId, depotId)
			deltaFile = os.path.join('/tmp', deltaFileName)
			bf = open(packageFile, "rb")
			df = open(deltaFile, "wb")
			ldf = librsync.DeltaFile(sig, bf)
			df.write(ldf.read())
			df.close()
			bf.close()
			ldf.close()
			
			packageSize = os.stat(packageFile)[stat.ST_SIZE]
			deltaSize = os.stat(deltaFile)[stat.ST_SIZE]
			speedup = int(packageSize/deltaSize)
			
			logger.notice("Delta calculated, upload speedup is %d" % speedup)
			if not self.quiet: print "  ", _("Delta calculated, upload speedup is %d") % speedup
			
			logger.notice("Starting delta upload of '%s' to depot '%s'" \
				% (deltaFileName, depotId))
			if not self.quiet: print "  ", _("Starting delta upload of '%s' to depot '%s'") \
							% (deltaFileName, depotId)
			
			repository.upload(deltaFile, deltaFileName, progressListener = self)
			
			logger.notice("Patching '%s'" % oldPackage)
			if not self.quiet: print "  ", _("Patching '%s'") % oldPackage
			
			be.librsyncPatchFile(lp + '/' + oldPackage, lp + '/' + deltaFileName, lp + '/' + destination)
			be.exit()
			
			os.unlink(deltaFile)
			repository.delete(deltaFileName)
		else:
			logger.notice("Starting upload of '%s' to depot '%s'" \
				% (os.path.basename(packageFile), depotId))
			if not self.quiet: print _("Starting upload of '%s' to depot '%s'") \
							% (os.path.basename(packageFile), depotId)
			repository.upload(packageFile, destination, progressListener = self)
		
		for oldPackage in oldPackages:
			logger.notice("Deleting '%s' from depot '%s'" % (oldPackage, depotId))
			repository.delete(oldPackage)
		
		be = self.getDepotConnection(depotId)
		rMD5 = be.getMD5Sum( self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile) )
		info = be.getDiskSpaceUsage( self.getLocalDepotPath(depotId) )
		be.exit()
		if (lMD5 != rMD5):
			# md5sum differ
			raise Exception("MD5sum of source '%s' and destination '%s' differ after upload to depot '%s'" % (lMD5, rMD5, depotId))
		
		if (info['usage'] >= 0.9):
			logger.warning("Warning: %d%% filesystem usage at repository on depot '%s'" % (int(100*info['usage']), depotId))
			if not self.quiet: print _("Warning: %d%% filesystem usage at repository on depot '%s'") % (int(100*info['usage']), depotId)
		
		logger.notice("Upload of '%s' to depot '%s' done" \
				% (os.path.basename(packageFile), depotId))
		if not self.quiet: print _("Upload of '%s' to depot '%s' done") \
						% (os.path.basename(packageFile), depotId)
	
	def installPackage(self, packageFile, depotId, tempDir=None):
		be = None
		try:
			logger.notice("Installing package '%s' on depot '%s'" \
				% (os.path.basename(packageFile), depotId))
			if not self.quiet: print _("Installing package '%s' on depot '%s'") \
						% (os.path.basename(packageFile), depotId)
			productId = self.getProductPackageFile(packageFile).product.productId
			
			be = self.getDepotConnection(depotId)
			
			defaultProperties = {}
			for p in self.getProductPackageFile(packageFile).product.productProperties:
				defaultProperties[p.name] = p.defaultValue
				
			if self.keepDefaultProductProperties:
				try:
					for p in be.getProductPropertyDefinitions_listOfHashes(productId, depotId):
						defaultProperties[p['name']] = p['default']
				except Exception, e:
					logger.warning(e)
			
			be.installPackage(packageFile, force = self.forceInstall, defaultProperties = defaultProperties, tempDir=tempDir)
			be.exit()
			logger.notice("Installation of package '%s' on depot '%s' finished" % (packageFile, depotId))
			if not self.quiet: print _("Installation of package '%s' on depot '%s' finished") \
						% (packageFile, depotId)
			if self.setupWhereInstalled:
				if 'setup' in self.getConfigBackend().getPossibleProductActions_list(productId = productId, depotId = depotId):
					self.setActionSetupWhereInstalled(productId, depotId)
				else:
					logger.warning("Cannot set action 'setup' for product '%s'" % productId)
			if self.updateWhereInstalled:
				if 'update' in self.getConfigBackend().getPossibleProductActions_list(productId = productId, depotId = depotId):
					self.setActionUpdateWhereInstalled(productId, depotId)
				else:
					logger.warning("Cannot set action 'update' for product '%s'" % productId)
			
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			raise
		
	def uninstallPackage(self, productId, depotId):
		be = None
		try:
			logger.notice("Uninstalling package '%s' on depot '%s'" % (productId, depotId))
			if not self.quiet: print _("Uninstalling package '%s' on depot '%s'") \
						% (productId, depotId)
			
			repositoryUrl = self.getRepositoryRemoteURL(depotId)
			logger.info("Using '%s' as repository url" % repositoryUrl)
			repository = getRepository(repositoryUrl, depotId, self.getConfigBackend().getOpsiHostKey(depotId))
			for destination in repository.content():
				if not destination.startswith(productId + '_'):
					continue
				logger.info("Deleting destination '%s' on depot '%s'" % (destination, depotId))
				repository.delete(destination)
			
			be = self.getDepotConnection(depotId)
			be.uninstallPackage(productId, force = self.forceUninstall, deleteFiles = self.deleteFilesOnUninstall)
			be.exit()
			logger.notice("Uninstall of package '%s' on depot '%s' finished" % (productId, depotId))
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			raise
		
	def progressChanged(self, progress):
		
		minutesLeft = str(int(progress.timeLeft/60))
		secondsLeft = str(int(progress.timeLeft%60))
		if (len(minutesLeft) < 2): minutesLeft = '0' + minutesLeft
		if (len(secondsLeft) < 2): secondsLeft = '0' + secondsLeft
		msg =   '   %8s' % ("%.2f" % progress.percent + '% ') \
			+ '%8s KB' % (progress.state/1024) \
			+ '%8s KB/s' % (int(progress.bytesPerSecond/1024)) \
			+ '%4s:%s ETAs' % (minutesLeft, secondsLeft) \
			+ ' - %s' % progress.name
		logger.info(msg)
		if not self.quiet: print msg



def printHelp():
	print \
	'''
Usage: %s [options] <command>

Manage opsi packages

Commands:
  -i, --install     <opsi-package> ...      install opsi packages
  -u, --upload      <opsi-package> ...      upload opsi packages to repositories
  -l, --list        <regex>                 list opsi packages matching regex
  -D, --differences <regex>                 show depot differences of opsi packages matching regex
  -r, --remove      <opsi-product-id> ...   uninstall opsi packages
  -x, --extract     <opsi-package> ...      extract opsi packages to local directory
  -V, --version                             show program's version info and exit
  -h, --help                                show this help message and exit

Options:
  -d, --depots      <depots>      comma separated list of depots to process
                                  this feature is not supported in the opsi community edition!
                                      (default: %s)
                                      use keyword ALL to process all known depots
  -p, --properties  <mode>        mode for default product property values
                      ask             display dialog
                      package         use defaults from package
                      keep            keep depot defaults (default)
  -f, --force                     force install/uninstall (use with extreme caution)
  -U, --update                    set action "update" on hosts where installation status is "installed"
  -S, --setup                     set action "setup" on hosts where installation status is "installed"
  --max-transfers   <num>         maximum number of simultaneous uploads
                                      0=unlimited (default)
  -o, --overwrite                 overwrite existing package even if size matches
  -k, --keep-files                do not delete client data dir on uninstall
  -t, --temp-dir    <path>        tempory directory for package install
  --interface       <type>        type of user interface
                      text            text based interface
                      snack           newt interface (default)
  -v, --verbose                   increase verbosity (can be used multiple times)
  -q, --quiet                     do not display any messages
  --log-file        <log-file>    path to debug log file
	''' % (os.path.basename(sys.argv[0]), socket.getfqdn())
#  --max-bandwidth   <kbps>        maximum transfer rate for each transfer (in kilobytes per second)
#                                      0=unlimited (default)
def printVersion():
	print "%s %s" % (os.path.basename(sys.argv[0]), __version__)

def main(argv):
	os.umask(0027)
	
	global opm
	global logLevel
	
	parser=OptionParser( add_help_option = False )
	
	parser.add_option("-h", "--help",           action="store_true", dest="help")
	parser.add_option("-V", "--version",        action="store_true", dest="version")
	parser.add_option("-v", "--verbose",        action="count",      dest="verbose")
	parser.add_option("-q", "--quiet",          action="store_true", dest="quiet")
	parser.add_option("-i", "--install",        action="store_true", dest="COMMAND_INSTALL")
	parser.add_option("-u", "--upload",         action="store_true", dest="COMMAND_UPLOAD")
	parser.add_option("-p", "--properties",     action="store",      dest="properties",   default="keep", choices=['ask', 'package', 'keep'])
	parser.add_option(      "--max-transfers",  action="store",      dest="maxTransfers", default = 0,    type="int")
	parser.add_option(      "--max-bandwidth",  action="store",      dest="maxBandwidth", default = 0,    type="int")
	parser.add_option("-l", "--list",           action="store_true", dest="COMMAND_LIST")
	parser.add_option("-D", "--differences",    action="store_true", dest="COMMAND_DIFFERENCES")
	parser.add_option("-r", "--remove",         action="store_true", dest="COMMAND_REMOVE")
	parser.add_option("-x", "--extract",        action="store_true", dest="COMMAND_EXTRACT")
	parser.add_option("-d", "--depots",         action="store",      dest="depots")
	parser.add_option("-f", "--force",          action="store_true", dest="force")
	parser.add_option("-k", "--keep-files",     action="store_true", dest="keepFiles")
	parser.add_option("-t", "--temp-dir",       action="store",      dest="tempDir")
	parser.add_option("-o", "--overwrite",      action="store_true", dest="overwriteAlways")
	parser.add_option("-S", "--setup",          action="store_true", dest="setupWhereInstalled")
	parser.add_option("-U", "--update",         action="store_true", dest="updateWhereInstalled")
	parser.add_option(      "--interface",      action="store",      dest="interface",    default="snack", choices=['text', 'snack'])
	parser.add_option(      "--log-file",       action="store",      dest="logFile")
	
	(options, args) = parser.parse_args()
	
	if options.help:
		printHelp()
		sys.exit(0)
	
	if options.version:
		printVersion()
		sys.exit(0)
	
	if options.logFile:
		if os.path.exists(options.logFile):
			os.unlink(options.logFile)
		logger.setLogFile(options.logFile)
		logger.setFileLevel(LOG_DEBUG2)
	
	if (options.properties == 'ask') and options.quiet:
		print >> sys.stderr, _("You cannot use properties=ask in quiet mode")
		sys.exit(1)
	
	if options.quiet:
		options.interface = 'dummy'
		logLevel = LOG_NONE
	elif options.verbose:
		logLevel = LOG_WARNING
		logLevel += options.verbose
		
	logger.setConsoleLevel(logLevel)
	
	cmds = 0
	for cmd in (	options.COMMAND_INSTALL, options.COMMAND_UPLOAD, options.COMMAND_LIST, \
			options.COMMAND_REMOVE, options.COMMAND_EXTRACT, options.COMMAND_DIFFERENCES ):
		if not cmd:
			continue
		cmds += 1
	if (cmds > 1):
		print >> sys.stderr, _("More than one command specified")
		sys.exit(1)
	elif (cmds < 1):
		print >> sys.stderr, _("No command specified")
		sys.exit(1)
	
	packageFiles = []
	productRegex = re.compile('.*')
	productIds = []
	if options.COMMAND_INSTALL or options.COMMAND_UPLOAD or options.COMMAND_EXTRACT:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi package given!")
			sys.exit(1)
		
		for p in args:
			p = os.path.abspath(p)
			if not os.path.exists(p):
				print >> sys.stderr, _("Package file '%s' does not exist!") % p
				sys.exit(1)
			packageFiles.append(p)
		
	elif options.COMMAND_LIST or options.COMMAND_DIFFERENCES:
		if args:
			if (len(args) > 1):
				printHelp()
				sys.exit(1)
			productRegex = re.compile(args[0])
	
	elif options.COMMAND_REMOVE:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi product id given!")
			sys.exit(1)
		productIds = args
	
	bm = BackendManager(authRequired=False)
	try:
		opm = OpsiPackageManager()
		
		opm.forceInstall = opm.forceUninstall = options.force
		opm.uiType = options.interface
		opm.quiet = options.quiet
		opm.maxTransfers = options.maxTransfers
		opm.maxBandwidth = options.maxBandwidth*1024
		opm.deleteFilesOnUninstall = not options.keepFiles
		opm.overwriteAlways = options.overwriteAlways
		opm.setupWhereInstalled = options.setupWhereInstalled
		opm.updateWhereInstalled = options.updateWhereInstalled
		
		# Command EXTRACT
		if options.COMMAND_EXTRACT:
			destination = os.path.abspath(os.getcwd())
			for p in packageFiles:
				opm.extractPackage(p, destination)
			return
		
		depotIds = [ socket.getfqdn() ]
		if options.depots:
			if (options.depots.lower() == 'all'):
				depotIds = bm.getDepotIds_list()
			else:
				depotIds = options.depots.lower().split(',')
				knownDepotIds = bm.getDepotIds_list()
				for depotId in depotIds:
					if depotId not in knownDepotIds:
						raise Exception("Depot '%s' not in list of known depots: %s" \
							% (depotId, ', '.join(knownDepotIds)))
		
		# Command INSTALL
		if options.COMMAND_INSTALL:
			if (options.properties == 'ask'):
				opm.keepDefaultProductProperties = False
				opm.productPropertiesDialog(packageFiles)
			elif (options.properties == 'keep'):
				opm.keepDefaultProductProperties = True
			elif (options.properties == 'package'):
				opm.keepDefaultProductProperties = False
			
			if not options.depots:
				# Direct install without upload
				for p in packageFiles:
					opm.installPackage(p, depotIds[0], tempDir=options.tempDir)
			else:
				opm.installOnDepots(packageFiles, depotIds, tempDir=options.tempDir)
		
		# Command UPLOAD
		elif options.COMMAND_UPLOAD:
			opm.uploadToRepositories(packageFiles, depotIds)
		
		# Command REMOVE
		elif options.COMMAND_REMOVE:
			opm.uninstallOnDepots(productIds, depotIds)
		
		# Command LIST
		elif options.COMMAND_LIST:
			terminalWidth = 60
			try:
				tty = os.popen('tty').readline().strip()
				fd = open(tty)
				terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
				fd.close()
			except:
				pass
			indent = "   "
			idWidth = versionWidth = int((terminalWidth-len(indent))/3)
			if (idWidth > 25): idWidth = 25
			if (versionWidth > 25): versionWidth = 25
			descriptionWidth = terminalWidth-len(indent)-idWidth-versionWidth-4
			
			for (depotId, productInfo) in opm.getProductInformations(depotIds).items():
				print "-"*(len(depotId)+4)
				print "- %s -" % depotId
				print "-"*(len(depotId)+4)
				print "%s%*s %*s %*s" % (indent, -1*idWidth, _('Product ID'),
							-1*versionWidth, _('Version'),
							-1*descriptionWidth, _('Description'))
				print "%s%s" % (indent, "="*(terminalWidth-len(indent)-2))
				productIds = productInfo.keys()
				productIds.sort()
				for productId in productIds:
					if not re.search(productRegex, productId):
						continue
					product = productInfo[productId]
					print "%s%*s %*s %*s" % (indent, -1*idWidth, productId,
							-1*versionWidth, product.get('productVersion', '') + '-' + product.get('packageVersion', ''),
							-1*descriptionWidth, product.get('description', '').replace('\n', '')[:descriptionWidth])
				print ""
		
		# Command DIFFERENCES
		elif options.COMMAND_DIFFERENCES:
			if options.COMMAND_DIFFERENCES and (len(depotIds) <= 1):
				print >> sys.stderr, _("More than one depot id needed to display differences")
				sys.exit(1)
			
			infos = opm.getProductInformations(depotIds)
			products = {}
			for (depotId, productInfo) in infos.items():
				productIds = productInfo.keys()
				productIds.sort()
				for productId in productIds:
					if not re.search(productRegex, productId):
						continue
					if not productId in products.keys():
						products[productId] = {
							'productVersion': None,
							'packageVersion': None
					}
				
			maxWidth = 0
			for depotId in depotIds:
				if (len(depotId) > maxWidth):
					maxWidth = len(depotId)
			
			for productId in products.keys():
				differs = False
				lines = []
				lines.append(productId)
				for (depotId, productInfo) in infos.items():
					lines.append( "    %*s: " % (-1*maxWidth, depotId) )
					product = productInfo.get(productId)
					if not product:
						lines[-1] += " not installed"
						differs = True
						continue
					if not products[productId]['productVersion']:
						products[productId]['productVersion'] = product.get('productVersion')
					elif (products[productId]['productVersion'] != product.get('productVersion')):
						differs = True
					
					if not products[productId]['packageVersion']:
						products[productId]['packageVersion'] = product.get('packageVersion')
					elif (products[productId]['packageVersion'] != product.get('packageVersion')):
						differs = True
					lines[-1] += " %s-%s" % (product.get('productVersion'), product.get('packageVersion'))
						
				if differs:
					for line in lines:
						print line
					print ""
					
		opm.cleanup()
		
	except Exception, e:
		if opm:	opm.cleanup()
		raise
	
	while(threading.activeCount() > 1):
		time.sleep(1)
	
	errors = opm.getErrors()
	if errors:
		print >> sys.stderr, _("Errors occured: ")
		for (name, errs) in errors.items():
			logger.error("Failure while processing: %s" % name)
			print >> sys.stderr, "   Failure while processing: %s" % name
			for err in errs:
				logger.error("      %s" % err)
				print >> sys.stderr, "   %s" % err
		sys.exit(1)
	

def signalHandler(signo, stackFrame):
	if (signo == SIGTERM or signo == SIGINT):
		logger.notice("Got signal %s, exiting when possible..." % signo)
		print >> sys.stderr, _("Got signal %s, exiting when possible..." % signo)
		if opm:
			opm.abort()
		sys.exit(1)
	
if (__name__ == "__main__"):
	if (os.name == 'posix'):
		from signal import *
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		#signal(SIGHUP, signalHandler)
		signal(SIGTERM, signalHandler)
		signal(SIGINT, signalHandler)
	
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		sys.exit(int(str(e)))
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, _("ERROR: ") + str(exception)
		sys.exit(1)
	
	sys.exit(0)



