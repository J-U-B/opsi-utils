#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = =
   =   opsi-makeproductfile    =
   = = = = = = = = = = = = = = =
   
   opsi-makeproductfile is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2010 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '3.4.99'

import os, time, getopt, gettext, re, pwd, grp, socket

# OPSI imports
from OPSI.Logger import *
from OPSI.System import *
from OPSI.Types import *
from OPSI.Util.Product import *
from OPSI.Util.File.Opsi import PackageControlFile
from OPSI.Util import md5sum
#from OPSI.Backend.BackendManager import BackendManager

# Get logger instance
logger = Logger()

# Get locale
try:
	t = gettext.translation('opsi_makeproductfile', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string
	
def usage():
	print u"\nUsage: %s [-h] [-v|-q] [-F format] [-l log-level] [-i|-c custom name] [-I required version] [-t temp dir] [source directory]" % os.path.basename(sys.argv[0])
	print u"Provides an opsi package from a package source directory."
	print u"If no source directory is supplied, the current directory will be used."
	print u"Options:"
	print u"   -v          verbose"
	print u"   -q          quiet"
	print u"   -l          log-level 0..9"
	print u"   -n          do not compress"
	print u"   -F          archive format [tar|cpio], default: cpio"
	print u"   -h          follow symlinks"
	print u"   -I          incremental package"
	print u"   -i          custom name (add custom files)"
	print u"   -c          custom name (custom only)"
	print u"   -t          temp dir"
	print u""


def lockPackage(tempDir, packageControlFile):
	lockFile = os.path.join(tempDir, u'.opsi-makeproductfile.lock.%s' % packageControlFile.getProduct().id)
	# Test if other processes are accessing same product
	try:
		lf = open(lockFile, 'r')
		p = lf.read().strip()
		lf.close()
		
		if p:
			for line in execute(u"ps -A"):
				line = line.strip()
				if not line:
					continue
				if (p == line.split()[0].strip()):
					pName = line.split()[-1].strip()
					# process is running
					raise Exception(u"Product '%s' is currently locked by process %s (%s)." \
								% (packageControlFile.getProduct().id, pName, p) )
	
	except IOError:
		pass
	
	# Write lock-file
	lf = open(lockFile, 'w')
	lf.write(os.getpid())
	lf.close()
	
def unlockPackage(tempDir, packageControlFile):
	lockFile = os.path.join(tempDir, u'.opsi-makeproductfile.lock.%s' % packageControlFile.getProduct().id)
	if os.path.isfile(lockFile):
		os.unlink(lockFile)

def main(argv):
	os.umask(022)
	
	logLevel         = LOG_WARNING
	packageSourceDir = os.getcwd()
	tempDir          = u'/tmp'
	lockFile         = None
	customName       = None
	customOnly       = False
	quiet            = False
	format           = 'cpio'
	compression      = 'gzip'
	dereference      = False
	requiredVersion  = None
	incremental      = False
	
	logger.setConsoleLevel(logLevel)
	logger.setConsoleColor(True)
	logger.setConsoleFormat(u'%L: %M')
	
	try:
		(opts, args) = getopt.getopt(argv, "hvnsi:c:t:l:F:I:")
	
	except getopt.GetoptError:
		usage()
		sys.exit(1)
	
	for (opt, arg) in opts:
		if   (opt == "-h"):
			dereference = True
		elif (opt == "-v"):
			logLevel = LOG_DEBUG
			logger.setColor(True)
		elif (opt == "-l"):
			logLevel = forceInt(arg)
			logger.setColor(True)
		elif (opt == "-n"):
			compression = None
		elif (opt == "-q"):
			logLevel = LOG_NONE
			quiet = True
		elif (opt == "-i"):
			customName = arg
		elif (opt == "-c"):
			customName = arg
			customOnly = True
		elif (opt == "-I"):
			requiredVersion = arg
			incremental = True
		elif (opt == "-t"):
			tempDir = forceFilename(arg)
		elif (opt == "-F"):
			format = forceUnicode(arg)
	
	if (len(args) > 1):
		logger.error(u"To many arguments")
		usage()
		sys.exit(1)
	
	elif (len(args) > 0):
		packageSourceDir = os.path.abspath( args[0] )
	
	logger.setConsoleLevel(logLevel)
	
	logger.info(u"Source dir: %s" % packageSourceDir)
	logger.info(u"Temp dir: %s" % tempDir)
	logger.info(u"Custom name: %s" % customName)
	logger.info(u"Archive format: %s" % format)
	
	if format not in ['tar', 'cpio']:
		raise Exception(u"Unsupported archive format: %s" % format)
	
	if not os.path.isdir(packageSourceDir):
		raise Exception(u"No such directory: %s" % packageSourceDir)
	
	packageControlFilePath = os.path.join(packageSourceDir, u'OPSI', u'control')
	if not os.path.exists(packageControlFilePath):
		raise Exception(u"Control file '%s' not found" % packageControlFilePath)
	
	if not quiet: print _(u"Locking package...")
	pcf = PackageControlFile(packageControlFilePath)
	
	lockPackage(tempDir, pcf)
	pps = None
	try:
		product = pcf.getProduct()
		if incremental:
			match = re.search('^\s*([<>]?=?)(^[<>=]+)\s*$', requiredVersion)
			if not match:
				raise Exception(u"Bad version string '%s' in dependency" % requiredVersion)
			packageDependency = { 'package': product.id, 'condition': match.group(1), 'version': match.group(2) }
			pcf.setPackageDependencies([ packageDependency ])
			pcf.setIncrementalPackage(True)
		
		if not quiet: print _(u"Product info:")
		if not quiet: print u"     productId:          %s" % product.id
		if not quiet: print u"     customName:         %s" % customName
		if not quiet: print u"     name:               %s" % product.name
		if not quiet: print u"     productVersion:     %s" % product.productVersion
		if not quiet: print u"     packageVersion:     %s" % product.packageVersion
		if not quiet: print u"     licenseRequired:    %s" % product.licenseRequired
		if not quiet: print u"     setupScript:        %s" % product.setupScript
		if not quiet: print u"     uninstallScript:    %s" % product.uninstallScript
		if not quiet: print u"     updateScript:       %s" % product.updateScript
		if not quiet: print u"     alwaysScript:       %s" % product.alwaysScript
		if not quiet: print u"     onceScript:         %s" % product.onceScript
		if not quiet: print u"     customScript:       %s" % product.customScript
		if not quiet: print u"     userLoginScript:    %s" % product.userLoginScript
		if not quiet: print u"     priority:           %s" % product.priority
		if not quiet: print u"     description:        %s" % product.description
		if not quiet: print u"     advice:             %s" % product.advice
		if not quiet: print u"     productClassNames:  %s" % product.productClassNames
		if not quiet: print u"     windowsSoftwareIds: %s" % product.windowsSoftwareIds
		if not quiet: print u"     pxeConfigTemplate:  %s" % product.pxeConfigTemplate
		
		pps = ProductPackageSource(
			packageSourceDir   = packageSourceDir,
			tempDir            = tempDir,
			customName         = customName,
			customOnly         = customOnly,
			packageFileDestDir = os.getcwd(),
			format             = format
			compression        = compression,
			dereference        = dereference)
		
		if not quiet: print _(u"Creating packagefile...")
		pps.pack(progressSubject = None)
		
		if not quiet: print _(u"Creating md5sum file '%s.md5'" % pps.packageFile)
		f = open(pps.packageFile + u'.md5', 'w')
		f.write(md5sum(pps.packageFile))
		f.close()
	finally:
		if pps:
			pps.cleanup()
		unlockPackage(tempDir, packageControlFile)
	
if (__name__ == "__main__"):
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(exception)
		print >> sys.stderr, u"ERROR: %s" % exception
		sys.exit(1)
	
	sys.exit(0)



