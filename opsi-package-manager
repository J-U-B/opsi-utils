#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = =
   =   opsi-package-manager    =
   = = = = = = = = = = = = = = =
   
   opsi-package-manager is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '1.1'

import sys, os, base64, re, stat, socket, threading, time, fcntl, math, random
from optparse import OptionParser, IndentedHelpFormatter
from twisted.web2 import responsecode
from twisted.web2.dav import davxml
from httplib import HTTPConnection, HTTPSConnection
import urllib, curses

from duplicity import librsync

from OPSI.Backend.Backend import *
from OPSI.Backend.BackendManager import BackendManager
from OPSI.Backend.JSONRPC import JSONRPCBackend
from OPSI.Logger import *
from OPSI.Product import *
from OPSI import Tools
from OPSI.UI import *

logger = Logger()
logLevel = LOG_NONE

opm = None

# Get locale
try:
	t = gettext.translation('opsi_package_manager', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string



import ctypes
 
 
def _async_raise(tid, excobj):
	res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj))
	if (res == 0):
		logger.error("_async_raise: nonexistent thread id")
		raise ValueError("nonexistent thread id")
	elif (res > 1):
		# """if it returns a number greater than one, you're in trouble, 
		# and you should call it again with exc=NULL to revert the effect"""
		ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
		logger.error("_async_raise: PyThreadState_SetAsyncExc failed")
		raise SystemError("PyThreadState_SetAsyncExc failed")
 
class KillableThread(threading.Thread):
	def raise_exc(self, excobj):
		if not self.isAlive():
			logger.error("Cannot terminate, thread must be started")
			return
		for tid, tobj in threading._active.items():
			if tobj is self:
				_async_raise(tid, excobj)
				return
	
	# the thread was alive when we entered the loop, but was not found 
	# in the dict, hence it must have been already terminated. should we raise
	# an exception here? silently ignore?
	
	def terminate(self):
		# must raise the SystemExit type, instead of a SystemExit() instance
		# due to a bug in PyThreadState_SetAsyncExc
		self.raise_exc(SystemExit)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =       Subjects                                                                    =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Subject(object):
	def __init__(self, id, type=''):
		self._id = id
		self._observers = []
		self._type = type
	
	def getId(self):
		return self._id
	
	def getClass(self):
		return self.__class__.__name__
	
	def getType(self):
		return self._type
	
	def attachObserver(self, observer):
		if not observer in self._observers:
			self._observers.append(observer)
	
	def detachObserver(self, observer):
		if observer in self._observers:
			self._observers.remove(observer)
	
	def serializable(self):
		return { "id": self.getId(), "type": self.getType(), "class": self.getClass() }
	
class MessageSubject(Subject):
	def __init__(self, id, type=''):
		Subject.__init__(self, id, type)
		self._message = ""
		self._severity = 0
	
	def setMessage(self, message, severity = 0):
		self._message = str(message)
		self._severity = severity
		self._notifyMessageChanged(message)
		
	def getMessage(self):
		return self._message
	
	def getSeverity(self):
		return self._severity
	
	def _notifyMessageChanged(self, message):
		for o in self._observers:
			o.messageChanged(self, message)
	
	def serializable(self):
		s = Subject.serializable(self)
		s['message'] = self.getMessage()
		s['severity'] = self.getSeverity()
		return s

class ChoiceSubject(MessageSubject):
	def __init__(self, id, type=''):
		MessageSubject.__init__(self, id, type)
		self._message = ""
		self._choices = []
		self._selectedIndex = -1
		self._callbacks = []
		
	def setSelectedIndex(self, selectedIndex):
		if not type(selectedIndex) is int:
			return
		if (selectedIndex > len(self._choices)-1):
			return
		self._selectedIndex = selectedIndex
		self._notifySelectedIndexChanged(selectedIndex)
	
	def getSelectedIndex(self):
		return self._selectedIndex
	
	def setChoices(self, choices):
		if not type(choices) in (list, tuple):
			choices = [ choices ]
		self._choices = choices
		if (len(self._choices) > 0) and (self._selectedIndex < 0):
			self._selectedIndex = 0
		self._notifyChoicesChanged(choices)
	
	def getChoices(self):
		return self._choices
	
	def selectChoice(self):
		logger.info("ChoiceSubject.selectChoice()")
		if (self._selectedIndex >= 0) and (self._selectedIndex < len(self._callbacks)):
			# Exceute callback
			logger.notice("Executing callback %s" % self._callbacks[self._selectedIndex])
			self._callbacks[self._selectedIndex](self)
		
	def setCallbacks(self, callbacks):
		if not type(callbacks) in (list, tuple):
			callbacks = [ callbacks ]
		self._callbacks = callbacks
	
	def _notifySelectedIndexChanged(self, selectedIndex):
		for o in self._observers:
			o.selectedIndexChanged(self, selectedIndex)
	
	def _notifyChoicesChanged(self, choices):
		for o in self._observers:
			o.choicesChanged(self, choices)
	
	def serializable(self):
		s = MessageSubject.serializable(self)
		s['choices'] = self.getChoices()
		s['selectedIndex'] = self.getSelectedIndex()
		return s

class ProgressSubject(MessageSubject):
	def __init__(self, id, type='', end=0):
		MessageSubject.__init__(self, id, type)
		if (end < 0): end = 0
		self._end = end
		self._percent = 0
		self._state = 0
		self._timeStarted = long(time.time())
		self._timeSpend = 0
		self._timeLeft = 0
		self._timeFired = 0
		self._speed = 0
	
	def setEnd(self, end):
		self._end = end
	
	def setState(self, state):
		if (state < 0): state = 0
		if (state > self._end): state = self._end
		self._state = state
		
		now = long(time.time())
		if (self._timeFired != now) or (self._state == self._end):
			if (self._end == 0):
				self._percent = 100
			else:
				self._percent = float(100)*(float(self._state) / float(self._end))
			
			self._timeSpend = now - self._timeStarted
			if self._timeSpend:
				self._speed = int(self._state/self._timeSpend)
				self._timeLeft = ((self._end-self._state)/self._speed)
			
			self._timeFired = now
			self._notifyProgressChanged(self._state, self._percent, self._timeSpend, self._timeLeft, self._speed)
	
	def addToState(self, amount):
		self.setState(self._state + amount)
	
	def getState(self):
		return self._state
	
	def getPercent(self):
		return self._percent
	
	def getTimeSpend(self):
		return self._timeSpend
		
	def getTimeLeft(self):
		return self._timeLeft
		
	def getSpeed(self):
		return self._speed
		
	def _notifyProgressChanged(self, state, percent, timeSpend, timeLeft, speed):
		for o in self._observers:
			o.progressChanged(self, state, percent, timeSpend, timeLeft, speed)
	
	def serializable(self):
		s = MessageSubject.serializable(self)
		s['state'] = self.getState()
		s['percent'] = self.getPercent()
		s['timeSpend'] = self.getTimeSpend()
		s['timeLeft'] = self.getTimeLeft()
		s['speed'] = self.getSpeed()
		return s

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =       Observers                                                                   =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class MessageObserver(object):
	def __init__(self):
		pass
	
	def messageChanged(self, subject, message):
		pass

class ChoiceObserver(MessageObserver):
	def __init__(self):
		MessageObserver.__init__(self)
	
	def selectedIndexChanged(self, subject, selectedIndex):
		pass
	
	def choicesChanged(self, subject, choices):
		pass

class ProgressObserver(MessageObserver):
	def __init__(self):
		pass
	
	def progressChanged(self, subject, state, percent, timeSpend, timeLeft, speed):
		pass

class NotificationObserver(ChoiceObserver):
	def __init__(self):
		pass
	
	def subjectsChanged(self, subjects):
		pass

class SubjectsObserver(ChoiceObserver, ProgressObserver):
	def __init__(self):
		self._subjects = []
	
	def setSubjects(self, subjects):
		for subject in self._subjects:
			subject.detachObserver(self)
		self._subjects = subjects
		for subject in self._subjects:
			subject.attachObserver(self)
		self.subjectsChanged(self._subjects)
	
	def addSubject(self, subject):
		if not subject in self._subjects:
			self._subjects.append(subject)
			subject.attachObserver(self)
		self.subjectsChanged(self._subjects)
	
	def removeSubject(self, subject):
		if subject in self._subjects:
			subject.detachObserver(self)
			self._subjects.remove(subject)
		self.subjectsChanged(self._subjects)
	
	def getSubjects(self):
		return self._subjects
	
	def subjectsChanged(self, subjects):
		pass

######################################################

class RepositoryError(Exception):
	ExceptionShortDescription = "Repository error"
	
	def __init__(self, message = None):
		self.message = message
	
	def __str__(self):
		#return "<%s: %s>" % (self.__class__.__name__, self.message)
		return str(self.message)
	
	def complete_message(self):
		if self.message:
			return "%s: %s" % (self.ExceptionShortDescription, self.message)
		else:
			return "%s" % self.ExceptionShortDescription

def getRepository(url, username='', password=''):
	if re.search('^file://', url):
		return FileRepository(url, username, password)
	if re.search('^webdavs*://', url):
		return WebDAVRepository(url, username, password)
	raise RepositoryError("Repository url '%s' not supported" % url)
	
class Repository:
	def __init__(self, url, username='', password=''):
		self._url = url
		self._username = username
		self._password = password
		self._path = ''
		self._maxBandwidth = 0
	
	def _absoluteDestination(self, destination):
		raise RepositoryError("Not implemented")
	
	def setMaxBandwidth(self, maxBandwidth):
		self._maxBandwidth = maxBandwidth
	
	def content(self, destination=''):
		raise RepositoryError("Not implemented")
		
	def upload(self, source, destination):
		raise RepositoryError("Not implemented")
		
	def delete(self, destination):
		raise RepositoryError("Not implemented")
	
	def fileInfo(self, destination):
		raise RepositoryError("Not implemented")
	
class FileRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^file://(/[^/]+.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		self._path = match.group(1)
		self._maxBandwidth = 0
		
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def content(self, destination=''):
		destination = self._absoluteDestination(destination)
		try:
			return os.listdir(destination)
		except:
			raise RepositoryError("Not a directory: '%s'" % destination)
	
	def fileInfo(self, destination):
		destination = self._absoluteDestination(destination)
		info = {}
		try:
			fs = os.stat(destination)
			info['size'] = fs[stat.ST_SIZE]
			return info
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
		
	def upload(self, source, destination, id, subjectsObserver=None):
		
		destination = self._absoluteDestination(destination)
		
		fs = os.stat(source)
		size = fs[stat.ST_SIZE]
		logger.debug("Length of binary data to upload: %d" % size)
		
		transferProgress = ProgressSubject(id, type='upload', end=size)
		transferProgress.setMessage( os.path.basename(source) )
		if subjectsObserver: subjectsObserver.addSubject(transferProgress)
		
		(src, dst) = (None, None)
		try:
			src = open(source, 'rb')
			dst = open(destination, 'wb')
			buf = True
			waitTime = 0.0
			bufferSize = 64*1024
			while(buf):
				t1 = time.time()
				buf = src.read(bufferSize)
				read = len(buf)
				if (read > 0):
					dst.write(buf)
					time.sleep(waitTime)
					t2 = time.time()
					dt = t2-t1
					if self._maxBandwidth and (dt > 0):
						speed = int(read/dt)
						wt = 0
						if (speed > 0) and (speed > self._maxBandwidth):
							wt = ( (float(speed)/float(self._maxBandwidth)) ** (0.1) )
						elif (speed > 0) and (speed < self._maxBandwidth):
							wt = ( (float(self._maxBandwidth)/float(speed)) ** (0.1) )
						if wt:
							while (wt > 1):
								wt -= 1
							if (wt > 0.2):
								wt = 0.2
							if (speed > self._maxBandwidth):
								waitTime += wt
							else:
								waitTime -= wt
							if (waitTime < 0):
								waitTime = 0.00001
					transferProgress.addToState(read)
			src.close()
			dst.close()
			if subjectsObserver: subjectsObserver.removeSubject(transferProgress)
		except Exception, e:
			if subjectsObserver: subjectsObserver.removeSubject(transferProgress)
			if src: src.close()
			if dst: dst.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
	
	def delete(self, destination):
		destination = self._absoluteDestination(destination)
		os.unlink(destination)
	
class WebDAVRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^(webdavs*)://([^:]+:*[^:]+):(\d+)(/.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		
		self._protocol = match.group(1)
		self._host = match.group(2)
		if (self._host.find('@') != -1):
			(username, self._host) = self._host.split('@', 1)
			password = ''
			if (username.find(':') != -1):
				(username, password) = username.split(':', 1)
			if not self._username and username: self._username = username
			if not self._password and password: self._password = password
		self._port = int(match.group(3))
		self._path = match.group(4)
		self._auth = 'Basic '+ base64.encodestring( urllib.unquote(self._username + ':' + self._password) ).strip()
		self._connection = None
		self._cookie = ''
		self._maxBandwidth = 0
		
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def _connect(self):
		logger.debug("WebDAVRepository _connect()")
		if self._protocol.endswith('s'):
			self._connection = HTTPSConnection(self._host, self._port)
		else:
			self._connection = HTTPConnection(self._host, self._port)
		
		self._connection.request("PROPFIND", "/products/", headers = { 'authorization': self._auth, 'depth': '0' })
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to connect to '%s://%s:%s': %s" \
				% (self._protocol, self._host, self._port, response.status))
		# We have to read the response!
		response.read()
		
		# Get cookie from header
		cookie = response.getheader('set-cookie', None)
		if cookie:
			# Store cookie 
			self._cookie = cookie.split(';')[0].strip()
	
	def _getContent(self, destination=''):
		
		content = []
		
		self._connect()
		
		self._connection.putrequest('PROPFIND', destination)
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.putheader('depth', '1')
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to list dir '%s': %s" \
				% (destination, response.status))
		
		msr = davxml.WebDAVDocument.fromString(response.read())
		if not msr.root_element.children[0].childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer).childOfType(davxml.ResourceType).children:
			raise RepositoryError("Not a directory: '%s'" % destination)
		for child in msr.root_element.children[1:]:
			#<prop>
			#	<resourcetype/>
			#	<getetag>W/"1737A0-373-47DFF2F3"</getetag>
			#	<getcontenttype>text/plain</getcontenttype>
			#	<getcontentlength>883</getcontentlength>
			#	<getlastmodified>Tue, 18 Mar 2008 17:50:59 GMT</getlastmodified>
			#	<creationdate>2008-03-18T17:50:59Z</creationdate>
			#	<displayname>connect.vnc</displayname>
			#</prop>
			pContainer = child.childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer)
			info = { 'size': long(0), 'type': 'file' }
			info['name'] = str(pContainer.childOfType(davxml.DisplayName))
			if (str(pContainer.childOfType(davxml.GETContentLength)) != 'None'):
				info['size'] = long( str(pContainer.childOfType(davxml.GETContentLength)) )
			if pContainer.childOfType(davxml.ResourceType).children:
				info['type'] = 'dir'
			
			content.append(info)
		
		return content
	
	def content(self, destination=''):
		result = []
		destination = self._absoluteDestination(destination)
		for c in self._getContent(destination):
			result.append( c['name'] )
		return result
	
	def fileInfo(self, destination):
		info = {}
		try:
			path = self._absoluteDestination('/'.join(destination.split('/')[:-1]))
			name = destination.split('/')[-1]
			for c in self._getContent(path):
				if (c['name'] == name):
					info['size'] = c['size']
					return info
			raise Exception('file not found')
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
	
	def upload(self, source, destination, transferProgress):
		destination = self._absoluteDestination(destination)
		src = None
		size = None
		try:
			fs = os.stat(source)
			size = fs[stat.ST_SIZE]
			logger.debug("Length of binary data to upload: %d" % size)
			
			transferProgress.setEnd(size)
			
			self._connect()
			
			self._connection.putrequest('PUT', destination)
			
			if self._cookie:
				# Add cookie to header
				self._connection.putheader('cookie', self._cookie)
			self._connection.putheader('authorization', self._auth)
			self._connection.putheader('content-length', size)
			self._connection.endheaders()
			
			src = open(source, 'rb')
			buf = True
			waitTime = 0.0
			bufferSize = 64*1024
			while(buf):
				t1 = time.time()
				buf = src.read(bufferSize)
				read = len(buf)
				if (read > 0):
					self._connection.send(buf)
					time.sleep(waitTime)
					t2 = time.time()
					dt = t2-t1
					if self._maxBandwidth and (dt > 0):
						speed = int(read/dt)
						wt = 0
						if (speed > 0) and (speed > self._maxBandwidth):
							wt = ( (float(speed)/float(self._maxBandwidth)) ** (0.1) )
						elif (speed > 0) and (speed < self._maxBandwidth):
							wt = ( (float(self._maxBandwidth)/float(speed)) ** (0.1) )
						if wt:
							while (wt > 1):
								wt -= 1
							if (wt > 0.2):
								wt = 0.2
							if (speed > self._maxBandwidth):
								waitTime += wt
							else:
								waitTime -= wt
							if (waitTime < 0):
								waitTime = 0.00001
					transferProgress.addToState(read)
			src.close()
			
			response = self._connection.getresponse()
			if (response.status != responsecode.CREATED) and (response.status != responsecode.NO_CONTENT):
				raise Exception(response.status)
			# We have to read the response!
			response.read()
			
		except Exception, e:
			logger.logException(e)
			if src: src.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
		logger.debug2("WebDAV upload done")
	
	def delete(self, destination):
		self._connect()
		
		destination = self._absoluteDestination(destination)
		
		self._connection.putrequest('DELETE', destination)
		
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.NO_CONTENT):
			raise RepositoryError("Failed to delete '%s': %s" \
				% (destination, response.status))
		# We have to read the response!
		response.read()
	


class Task:
	def __init__(self, name, opsiPackageManager, method, params):
		self.name = name
		self.opsiPackageManager = opsiPackageManager
		self.method = method
		self.params = params
		if not type(self.params) in (tuple, list):
			self.params = [ self.params ]
		self.started = False
		self.ended = False
		self.aborted = False
		self.exception = None
		self.result = None
			
	def abort(self):
		self.aborted = True
	
	def isRunning(self):
		return self.started and not self.ended
		
	def start(self):
		logger.info("Task '%s' started" % self.name)
		self.started = True
		try:
			logger.debug2("Method: %s" % self.method)
			logger.debug2("Params: %s" % str(self.params))
			self.result = self.method( *self.params )
		except Exception, e:
			logger.info("Task '%s' failed" % self.name)
			logger.logException(e)
			self.exception = e
			self.ended = True
			raise
		logger.info("Task '%s' ended" % self.name)
		self.ended = True

class UploadTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)
	
class InstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class UninstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class TaskQueue(KillableThread):
	def __init__(self, name, stopOnError = False, id = None):
		threading.Thread.__init__(self)
		self.name = name
		self.tasks = []
		self.started = False
		self.ended = False
		self.aborted = False
		self.errors = []
		self.currentTaskNumber = -1
		self.id = id
		self.stopOnError = stopOnError
		self.lastTaskResult = None
		
	def abort(self):
		task = self.getCurrentTask()
		if task:
			task.abort()
		self.aborted = True
		self.errors.append('Aborted')
		if self.isAlive():
			self.terminate()
		self.ended = True
		
	def getCurrentTask(self):
		if (self.currentTaskNumber < 0):
			return None
		return self.tasks[self.currentTaskNumber]
	
	def run(self):
		self.currentTaskNumber = -1
		if not self.tasks:
			raise Exception("No tasks in queue")
		self.started = True
		logger.debug("TaskQueue '%s' started" % self.name)
		i = 0
		while (i < len(self.tasks)):
			if self.aborted: break
			task = self.tasks[i]
			try:
				logger.debug("Starting task '%s'" % task.name)
				self.currentTaskNumber += 1
				task.start()
				self.lastTaskResult = task.result
				logger.debug("Task '%s' ended" % task.name)
				if (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], UploadTask):
					# Sleeping 3 seconds to provide the opportunity to start other upload tasks
					time.sleep(3)
			except Exception, e:
				logger.error("Task '%s' failed: %s" % (task.name, e))
				self.errors.append(e)
				self.lastTaskResult = None
				if self.stopOnError:
					i = len(self.tasks)
				elif (i < len(self.tasks)-1) and isinstance(task, UploadTask) and isinstance(self.tasks[i+1], InstallTask):
					# Upload task failed => do not execute install task
					logger.notice("Upload task failed, skipping install task")
					i += 1
			i += 1
		self.ended = True
		
		
	def addTask(self, task):
		if not isinstance(task, Task):
			raise ValueError("Task wanted, '%s' passed")
		self.tasks.append(task)

class OpsiPackageManager:
	
	def __init__(self):
		self.productPackageFiles = {}
		self.productPackageMD5Sums = {}
		self.maxTransfers = 0
		self.runningTransfers = 0
		self.maxBandwidth = 0
		self.overwriteIfMD5SumDiffers = True
		self.overwriteAlways = False
		self.deltaUpload = True
		self.forceInstall = False
		self.keepDefaultProductProperties = False
		self.deleteFilesOnUninstall = True
		self.setupWhereInstalled = False
		self.updateWhereInstalled = False
		self.quiet = True
		self.taskQueues = []
		self.uiType = 'snack'
		self.ui = None
		self.infoSubject = MessageSubject('info')
		self.transferSubject = MessageSubject('transfers')
		self.userInterface = None
		self.consoleLevelSaved = LOG_NONE
		self.aborted = False
		
		self.depotSubjects = {}
		
		self.infoSubject.setMessage('opsi-package-manager')
		
		logger.info("OpsiPackageManager initiated")
	
	def setQuiet(self, quiet):
		self.quiet = quiet
		self.userInterface = None
		if not self.quiet:
			self.userInterface = UserInterface( subjects = [ self.infoSubject, self.transferSubject ] )
		
	def getConfigBackend(self):
		return BackendManager(authRequired=False)
	
	def createDepotSubjects(self, depotIds):
		if self.depotSubjects and self.userInterface:
			for subject in self.depotSubjects.values():
				self.userInterface.removeSubject(subject)
		for depotId in depotIds:
			self.depotSubjects[depotId] = MessageSubject(id = depotId, type = 'depot')
			if self.userInterface:
				self.userInterface.addSubject(self.depotSubjects[depotId])
		
	def getDepotSubject(self, depotId):
		return self.depotSubjects.get(depotId)
		
	def abort(self):
		self.aborted = True
		running = True
		while running:
			running = False
			for tq in self.taskQueues:
				if not tq.ended:
					logger.notice("Aborting task queue '%s'" % tq.name)
					tq.abort()
		
	def cleanup(self):
		if self.userInterface:
			self.userInterface.exit()
		self.exitUi()
		for productPackageFile in self.productPackageFiles.values():
			productPackageFile.cleanup()
		
	def openProductPackageFile(self, packageFile):
		self.infoSubject.setMessage( _('Opening package file %s' % os.path.basename(packageFile)) )
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.productPackageFiles[os.path.basename(packageFile)] = ProductPackageFile(packageFile)
	
	def getProductPackageFile(self, packageFile):
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.openProductPackageFile(packageFile)
		return self.productPackageFiles.get(os.path.basename(packageFile))
	
	def extractPackage(self, packageFile, destination):
		self.getProductPackageFile(packageFile).unpackSource(destination)
	
	def getMD5Sum(self, packageFile):
		if not self.productPackageMD5Sums.has_key(os.path.basename(packageFile)):
			self.productPackageMD5Sums[os.path.basename(packageFile)] = Tools.md5sum(packageFile)
		return self.productPackageMD5Sums[os.path.basename(packageFile)]
	
	def getDepotConnection(self, depotId):
		depotKey = self.getConfigBackend().getOpsiHostKey(depotId)
		return JSONRPCBackend( username = depotId, password = depotKey, address = depotId )
	
	def getLocalDepotPath(self, depotId):
		depot = self.getConfigBackend().getDepot_hash(depotId)
		localPath = depot['repositoryLocalUrl']
		if not localPath.startswith('file://'):
			raise Exception("Repository local url '%s' not allowed" % localPath)
		localPath = localPath[7:]
		if localPath.endswith('/'):
			localPath = localPath[:-1]
		return localPath
	
	def getRepositoryRemoteURL(self, depotId):
		depot = self.getConfigBackend().getDepot_hash(depotId)
		return depot['repositoryRemoteUrl']
	
	def getRunningTransfers(self):
		return self.runningTransfers
	
	def setRunningTransfers(self, num):
		self.runningTransfers = num
		if self.maxTransfers:
			self.transferSubject.setMessage( _("%d/%d transfers running") \
				% (self.runningTransfers, self.maxTransfers) )
		else:
			self.transferSubject.setMessage( _("%d transfers running") \
				% self.runningTransfers )
		
	def maxTransfersReached(self):
		if self.maxTransfers and (self.getRunningTransfers() >= self.maxTransfers):
			return True
		return False
	
	def waitForTaskQueues(self):
		self.infoSubject.setMessage( _('Waiting for task queues to finish up') )
		running = 1
		while running:
			running = 0
			for tq in self.taskQueues:
				if not tq.ended:
					logger.debug("Task queue %s running, waiting" % tq.name)
					running +=1
			self.infoSubject.setMessage( _('%d/%d task queues running') \
								% (running, len(self.taskQueues)) )
			time.sleep(1)
		
	def getErrors(self):
		errors = {}
		for tq in self.taskQueues:
			if not tq.errors:
				continue
			errors[tq.name] = tq.errors
		return errors
	
	def initUi(self):
		if not self.ui:
			self.consoleLevelSaved = logger.getConsoleLevel()
			logger.setConsoleLevel(LOG_NONE)
			self.ui = UIFactory(self.uiType)
			self.ui.drawRootText(1, 1, _('Open PC ServerIntegration'))
			setUI(self.ui)
	
	def exitUi(self):
		if self.ui:
			self.ui.exit()
			logger.setConsoleLevel(self.consoleLevelSaved)
			
	def productPropertiesDialog(self, packageFiles):
		self.initUi()
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for packageFile in packageFiles:
			productId = self.getProductPackageFile(packageFile).product.productId
			for p in self.getProductPackageFile(packageFile).product.productProperties:
				defaultValue = p.defaultValue
				if (len(p.possibleValues) > 0):
					values = []
					for v in p.possibleValues:
						values.append( { "name": v, "selected": (v == defaultValue) } )
					defaultValue = self.ui.getSelection(values, radio=True,
									title=_("Default value for product '%s', property '%s'") % (productId, p.name), 
									text=p.description)
					if defaultValue != None:
						defaultValue = defaultValue[0]
				else:
					defaultValue = self.ui.getValue(text=p.description, default=defaultValue)
					
				if (defaultValue != None):
					p.defaultValue = defaultValue
		self.exitUi()
	
	def getProductInformationsFromDepots(self, depotIds):
		self.createDepotSubjects(depotIds)
		
		logger.debug('Getting product informations')
		for depotId in depotIds:
			tq = TaskQueue(name = "Get product infos from depot %s" % depotId, id = depotId)
			tq.addTask(
				Task(
					name = "Get product infos from depot %s" % depotId,
					opsiPackageManager = self,
					method = self.getProductInformationsFromDepot,
					params = (depotId)
				)
			)
			if not self.aborted:
				self.taskQueues.append(tq)
				logger.info("Starting task queue '%s'" % tq.name)
				tq.start()
		
		self.waitForTaskQueues()
		info = {}
		for tq in self.taskQueues:
			if tq.errors:
				raise Exception("Failed to get product informations: %s" % tq.errors[0])
			info[tq.id] = tq.lastTaskResult
		return info
	
	def uploadToRepositories(self, packageFiles, depotIds):
		self.createDepotSubjects(depotIds)
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
			
		for depotId in depotIds:
			tq = TaskQueue(name = "Upload of package(s) %s to repository '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
			if not self.aborted:
				self.taskQueues.append(tq)
				logger.info("Starting task queue '%s'" % tq.name)
				tq.start()
		self.waitForTaskQueues()
		
	def installOnDepots(self, packageFiles, depotIds, tempDir=None):
		self.createDepotSubjects(depotIds)
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for depotId in depotIds:
			tq = TaskQueue(name = "Install of package(s) %s on depot '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
				tq.addTask(
					InstallTask(
						name = "Install of package '%s' on depot '%s'" % (os.path.basename(packageFile), depotId),
						opsiPackageManager = self,
						method = self.installPackage,
						params = (os.path.basename(packageFile), depotId, tempDir)
					)
				)
			if not self.aborted:
				self.taskQueues.append(tq)
				logger.info("Starting task queue '%s'" % tq.name)
				tq.start()
		self.waitForTaskQueues()
		
	def uninstallOnDepots(self, productIds, depotIds):
		self.createDepotSubjects(depotIds)
		
		for depotId in depotIds:
			tq = TaskQueue(name = "Uninstall of package(s) %s on depot '%s'" % (', '.join(productIds), depotId))
			for productId in productIds:
				tq.addTask(
					UninstallTask(
						name = "Uninstall of package '%s' on depot '%s'" % (productId, depotId),
						opsiPackageManager = self,
						method = self.uninstallPackage,
						params = (productId, depotId)
					)
				)
			if not self.aborted:
				self.taskQueues.append(tq)
				logger.info("Starting task queue '%s'" % tq.name)
				tq.start()
	
	def getProductInformationsFromDepot(self, depotId):
		info = {}
		be = None
		subject = self.getDepotSubject(depotId)
		try:
			logger.notice("Connecting to depot %s" % depotId)
			subject.setMessage("Connecting to depot")
			be = self.getDepotConnection(depotId)
			logger.notice("Getting product info from depot %s" % depotId)
			subject.setMessage("Getting product info")
			for productId in be.getProductIds_list(objectId = depotId):
				info[productId] = be.getProduct_hash(productId = productId, depotId = depotId)
			logger.notice("Got product info from depot %s" % depotId)
			subject.setMessage("Got product info", severity = 'SUCCESS')
			return info
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
	
	def setActionSetupWhereInstalled(self, productId, depotId):
		subject = self.getDepotSubject(depotId)
		try:
			subject.setMessage( _("Setting action setup for product %s where installed") % productId )
			clientIds = self.getConfigBackend().getClientIds_list(depotId = depotId, productId = productId, installationStatus = 'installed')
			clientIds.sort()
			if not clientIds:
				return
			logger.notice("Setting action 'setup' for product '%s' on client(s): %s" % (productId, ', '.join(clientIds)))
			subject.setMessage( _("Setting action setup for product %s on client(s): %s") % (productId, ', '.join(clientIds)) )
			for clientId in clientIds:
				self.getConfigBackend().setProductActionRequest(productId, clientId, 'setup')
		except Exception, e:
			logger.error(e)
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
		
	def setActionUpdateWhereInstalled(self, productId, depotId):
		subject = self.getDepotSubject(depotId)
		try:
			subject.setMessage( _("Setting action update for product %s where installed") % productId )
			clientIds = self.getConfigBackend().getClientIds_list(depotId = depotId, productId = productId, installationStatus = 'installed')
			clientIds.sort()
			if not clientIds:
				return
			logger.notice("Setting action 'update' for product '%s' on client(s): %s" % (productId, ', '.join(clientIds)))
			subject.setMessage( _("Setting action update for product %s on client(s): %s") % (productId, ', '.join(clientIds)) )
			for clientId in clientIds:
				self.getConfigBackend().setProductActionRequest(productId, clientId, 'update')
		except Exception, e:
			logger.error(e)
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
	
	def uploadToRepository(self, packageFile, depotId):
		subject = self.getDepotSubject(depotId)
		try:
			# Process upload
			logger.notice("Processing upload of '%s' to depot '%s'" \
					% (os.path.basename(packageFile), depotId))
			subject.setMessage( _("Processing upload of %s") % os.path.basename(packageFile) )
			
			packageSize = os.stat(packageFile)[stat.ST_SIZE]
			lMD5 = self.getMD5Sum(packageFile)
			destination = os.path.basename(packageFile)
			
			productId = self.getProductPackageFile(packageFile).product.productId
			
			repositoryUrl = self.getRepositoryRemoteURL(depotId)
			logger.info("Using '%s' as repository url" % repositoryUrl)
			
			repository = getRepository(repositoryUrl, depotId, self.getConfigBackend().getOpsiHostKey(depotId))
			repository.setMaxBandwidth(self.maxBandwidth)
			
			if destination in repository.content():
				logger.info("Destination '%s' already exists on depot '%s'" % (destination, depotId))
				if not self.overwriteAlways:
					# Not overwriting always
					if not self.overwriteIfMD5SumDiffers:
						# Do not check md5sum => do not overwrite
						return
					# Checking file sizes first
					if ( repository.fileInfo(destination)['size'] != packageSize ):
						# Size differs => overwrite
						logger.info("Size of source and destination differs on depot '%s'" % depotId)
					else:
						# Sizes match => check md5sum
						logger.info("Size of source and destination matches on depot '%s'" % depotId)
						be = self.getDepotConnection(depotId)
						rMD5 = be.getMD5Sum( self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile) )
						be.exit()
						if (lMD5 == rMD5):
							# md5sum match => do not overwrite
							logger.info("MD5sum of source and destination matches on depot '%s'" % depotId)
							subject.setMessage( _("No need to upload, %s is up to date") % os.path.basename(packageFile), severity = 'SUCCESS' )
							return
						# md5sums differ => overwrite
						logger.info("MD5sum of source and destination differs on depot '%s'" % depotId)
						
				logger.info("Overwriting destination '%s' on depot '%s'" % (destination, depotId))
				subject.setMessage( _("Overwriting destination %s") % destination )
			
			be = self.getDepotConnection(depotId)
			info = be.getDiskSpaceUsage( self.getLocalDepotPath(depotId) )
			be.exit()
			if (info['available'] < packageSize):
				subject.setMessage( _("Not enough disk space: %dMB needed, %dMB available") \
							% ( (packageSize/(1024*1024)), (info['available']/(1024*1024)) ) )
				raise Exception("Not enough disk space on depot '%s': %dMB needed, %dMB available" \
							% (depotId, (packageSize/(1024*1024)), (info['available']/(1024*1024))))
			
			oldPackages = []
			for dest in repository.content():
				if dest.startswith(productId + '_') and not (dest == destination):
					# same product, other version
					oldPackages.append(dest)
			newOldPackages = []
			
			if self.maxTransfersReached():
				subject.setMessage( _("Waiting for free upload slot for %s") % os.path.basename(packageFile) )
				while self.maxTransfersReached():
					time.sleep(0.1 * random.randint(1, 20))
			self.setRunningTransfers(self.getRunningTransfers() + 1)
			subject.setMessage( _("Starting upload") )
			try:
				if self.deltaUpload and oldPackages:
					oldPackage = oldPackages[0]
					be = self.getDepotConnection(depotId)
					lp = self.getLocalDepotPath(depotId)
					
					logger.notice("Getting librsync signature of '%s'" % oldPackage)
					subject.setMessage( _("Getting librsync signature of %s") % oldPackage )
					
					sig = base64.decodestring( be.librsyncSignature(lp + '/' + oldPackage) )
					
					logger.notice("Calculating delta")
					subject.setMessage( _("Calculating delta") )
					
					deltaFilename = '%s_%s.delta' % (productId, depotId)
					
					if deltaFilename in oldPackages:
						newDeltaFilename = deltaFilename
						i = 0
						while newDeltaFilename in oldPackages:
							newDeltaFilename = deltaFilename + '.' + str(i)
							i += 1
						deltaFilename = newDeltaFilename
					
					deltaFile = os.path.join('/tmp', deltaFilename)
					bf = open(packageFile, "rb")
					df = open(deltaFile, "wb")
					ldf = librsync.DeltaFile(sig, bf)
					df.write(ldf.read())
					df.close()
					bf.close()
					ldf.close()
					
					packageSize = os.stat(packageFile)[stat.ST_SIZE]
					deltaSize = os.stat(deltaFile)[stat.ST_SIZE]
					speedup = (float(packageSize)/float(deltaSize))-1
					if (speedup < 0):
						speedup = 0
					logger.notice("Delta calculated, upload speedup is %.3f" % speedup)
					logger.notice("Starting delta upload of '%s' to depot '%s'" \
						% (deltaFilename, depotId))
					subject.setMessage( _("Starting delta upload of %s") \
									% os.path.basename(packageFile) )
					
					progressSubject = ProgressSubject(id = depotId, type = 'upload')
					progressSubject.setMessage("Uploading %s (delta upload, speedup %.1f%%)" \
									% (os.path.basename(packageFile), speedup*100) )
					if self.userInterface:
						self.userInterface.addSubject(progressSubject)
					
					repository.upload(deltaFile, deltaFilename, progressSubject)
					
					if self.userInterface:
						self.userInterface.removeSubject(progressSubject)
					
					logger.notice("Patching '%s'" % oldPackage)
					subject.setMessage( _("Patching %s") % oldPackage )
					
					be.librsyncPatchFile(lp + '/' + oldPackage, lp + '/' + deltaFilename, lp + '/' + destination)
					be.exit()
					
					os.unlink(deltaFile)
					repository.delete(deltaFilename)
				else:
				
					logger.notice("Starting upload of '%s' to depot '%s'" 	% (os.path.basename(packageFile), depotId))
					subject.setMessage( _("Starting upload of %s") % os.path.basename(packageFile) )
					
					progressSubject = ProgressSubject(id = depotId, type = 'upload')
					progressSubject.setMessage("Uploading %s" % os.path.basename(packageFile))
					if self.userInterface:
						self.userInterface.addSubject(progressSubject)
					
					repository.upload(packageFile, destination, progressSubject)
					
					if self.userInterface:
						self.userInterface.removeSubject(progressSubject)
			finally:
				self.setRunningTransfers(self.getRunningTransfers() - 1)
			
			logger.notice("Upload of '%s' to depot '%s' finished" % (os.path.basename(packageFile), depotId))
			subject.setMessage( _("Upload of %s finished") % os.path.basename(packageFile) )
			
			for oldPackage in oldPackages:
				if (oldPackage == destination):
					continue
				try:
					logger.notice("Deleting '%s' from depot '%s'" % (oldPackage, depotId))
					repository.delete(oldPackage)
				except Exception, e:
					logger.error("Failed to delete '%s' from depot '%s': %s" % (oldPackage, depotId, e))
			
			logger.notice("Verifying upload")
			subject.setMessage( _("Verifying upload") )
			
			be = self.getDepotConnection(depotId)
			rMD5 = be.getMD5Sum( self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile) )
			info = be.getDiskSpaceUsage( self.getLocalDepotPath(depotId) )
			be.exit()
			if (lMD5 != rMD5):
				# md5sum differ
				raise Exception("MD5sum of source '%s' and destination '%s' differ after upload to depot '%s'" % (lMD5, rMD5, depotId))
			
			if (info['usage'] >= 0.9):
				logger.warning("Warning: %d%% filesystem usage at repository on depot '%s'" % (int(100*info['usage']), depotId))
				subject.setMessage( _("Warning: %d%% filesystem usage") % int(100*info['usage']), severity = 'WARNING' )
			
			logger.notice("Upload of %s successful" % os.path.basename(packageFile))
			subject.setMessage( _("Upload of %s successful") % os.path.basename(packageFile), severity = 'SUCCESS')
			
		except Exception, e:
			logger.error(e)
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
			
	def installPackage(self, packageFile, depotId, tempDir=None):
		subject = self.getDepotSubject(depotId)
		
		be = None
		try:
			localFile = self.getLocalDepotPath(depotId) + '/' + packageFile
			logger.notice("Installing package '%s' on depot '%s'" % (packageFile, depotId))
			subject.setMessage( _("Installing package %s") % packageFile )
			productId = self.getProductPackageFile(packageFile).product.productId
			
			be = self.getDepotConnection(depotId)
			
			defaultProperties = {}
			for p in self.getProductPackageFile(packageFile).product.productProperties:
				defaultProperties[p.name] = p.defaultValue
				
			if self.keepDefaultProductProperties:
				try:
					for p in be.getProductPropertyDefinitions_listOfHashes(productId, depotId):
						defaultProperties[p['name']] = p['default']
				except Exception, e:
					logger.warning(e)
			
			be.installPackage(localFile, force = self.forceInstall, defaultProperties = defaultProperties, tempDir=tempDir)
			be.exit()
			logger.notice("Installation of package '%s' on depot '%s' successful" % (localFile, depotId))
			subject.setMessage( _("Installation of package %s successful") % packageFile, severity = 'SUCCESS' )
			
			if self.setupWhereInstalled:
				if 'setup' in self.getConfigBackend().getPossibleProductActions_list(productId = productId, depotId = depotId):
					self.setActionSetupWhereInstalled(productId, depotId)
				else:
					logger.warning("Cannot set action 'setup' for product '%s'" % productId)
			if self.updateWhereInstalled:
				if 'update' in self.getConfigBackend().getPossibleProductActions_list(productId = productId, depotId = depotId):
					self.setActionUpdateWhereInstalled(productId, depotId)
				else:
					logger.warning("Cannot set action 'update' for product '%s'" % productId)
			
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
		
	def uninstallPackage(self, productId, depotId):
		subject = self.getDepotSubject(depotId)
		
		be = None
		try:
			logger.notice("Uninstalling package '%s' on depot '%s'" % (productId, depotId))
			subject.setMessage( _("Uninstalling package %s") % productId )
			
			repositoryUrl = self.getRepositoryRemoteURL(depotId)
			logger.info("Using '%s' as repository url" % repositoryUrl)
			repository = getRepository(repositoryUrl, depotId, self.getConfigBackend().getOpsiHostKey(depotId))
			for destination in repository.content():
				if not destination.startswith(productId + '_'):
					continue
				logger.info("Deleting destination '%s' on depot '%s'" % (destination, depotId))
				repository.delete(destination)
			
			be = self.getDepotConnection(depotId)
			be.uninstallPackage(productId, force = self.forceUninstall, deleteFiles = self.deleteFilesOnUninstall)
			be.exit()
			
			logger.notice("Package '%s' uninstalled on depot '%s'" % (productId, depotId))
			subject.setMessage( _("Package %s uninstalled") % productId )
			
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			if type(e) is dict and e.has_key('message'): e = e['message']
			subject.setMessage( _("Error: %s") % e, severity = 'ERROR' )
			raise
	

class CursesWindow:
	def __init__(self, height, width, y, x, title = '', border = False):
		self.height = height
		self.width = width
		self.y = y
		self.x = x
		self.title = title
		self.border = border
		self.color = None
		self.win = curses.newwin(self.height, self.width, self.y, self.x)
		if self.border:
			self.win.border()
		self.setTitle(self.title)
		self.refresh()
	
	def resize(self, height, width, y, x):
		self.height = height
		self.width = width
		self.y = y
		self.x = x
		try:
			self.win.resize(height, width)
			self.win.mvwin(y, x)
			self.win.redrawwin()
			self.win.refresh()
		except:
			pass

	def setTitle(self, title):
		self.title = title
		if not title:
			return
		if (len(title) > self.width-4):
			title = title[:self.width-4]
		title = '| ' + title + ' |'
		attr = curses.A_NORMAL
		if self.color:
			attr |= self.color
		try:
			self.win.addstr(
				0,
				int((self.width-len(title))/2),
				title,
				attr)
		except: pass
	
	def setColor(self, colorPair):
		if not curses.has_colors():
			return
		self.color = colorPair
		self.win.attrset(self.color)
		self.win.bkgdset(' ', self.color)
		self.win.clear()
		if self.border:
			self.win.border()
		self.setTitle(self.title)
		self.refresh()
	
	def setScrollable(self, scrollable):
		if scrollable:
			scrollable = 1
		else:
			scrollable = 0
		self.win.scrollok(scrollable)
		self.win.idlok(scrollable)
	
	def addstr(self, *attr):
		try:
			self.win.addstr(*attr)
		except: pass
	
	def clrtoeol(self):
		try:
			self.win.clrtoeol()
		except: pass
	
	def move(self, y, x):
		try:
			self.win.move(y, x)
		except: pass
	
	def clear(self):
		try:
			self.win.clear()
		except: pass
	
	def refresh(self):
		try:
			self.win.refresh()
		except: pass
	
	def redraw(self):
		try:
			self.win.redrawwin()
			self.win.refresh()
		except: pass
	
class CursesMainWindow(CursesWindow):
	def __init__(self):
		self.initScreen()
	
	def __del__(self):
		self.exitScreen()
	
	def initScreen(self):
		self.win = curses.initscr()
		(self.height, self.width) = self.win.getmaxyx()
		(self.x, self.y) = (0, 0)
		curses.noecho()
		curses.cbreak()
		self.win.keypad(1)
		curses.start_color()
		self.refresh()
	
	def exitScreen(self):
		curses.nocbreak()
		self.win.keypad(0)
		curses.echo()
		curses.endwin()
	
	def resize(self):
		self.exitScreen()
		self.initScreen()
		#(self.height, self.width) = self.win.getmaxyx()
	
	
class CursesTextWindow(CursesWindow):
	def __init__(self, height, width, y, x, title = '', border = False):
		CursesWindow.__init__(self, height, width, y, x, title, border)
		self.lines = []
		self._lock = threading.Lock()
		
	def addLine(self, line, *params):
		self._lock.acquire()
		if (len(line) > self.width):
			line = line[:self.width-1]
			self.lines.append( (line, params) )
		self.build()
		self._lock.release()
	
	def addLines(self, lines, *params):
		self._lock.acquire()
		for line in lines:
			if (len(line) > self.width):
				line = line[:self.width-1]
			self.lines.append( (line, params) )
		self.build()
		self._lock.release()
	
	def setLines(self, lines, *params):
		self._lock.acquire()
		self.lines = []
		for line in lines:
			if (len(line) > self.width):
				line = line[:self.width-1]
			self.lines.append( (line, params) )
		self.build()
		self._lock.release()
	
	def getLines(self):
		return self.lines
	
	def build(self):
		if (len(self.lines) > self.height):
			self.lines = self.lines[-1*self.height:]
		for i in range(len(self.lines)):
			if (i >= len(self.lines)) or (i >= self.height):
				return
			self.move(i, 0)
			self.clrtoeol()
			(line, params) = self.lines[i]
			if params:
				self.addstr(line, *params)
			else:
				self.addstr(line)
	
	def resize(self, height, width, y, x):
		CursesWindow.resize(self, height, width, y, x)
		newLines = []
		for i in range(len(self.lines)):
			(line, params) = self.lines[i]
			if (len(line) > self.width):
				line = line[:self.width-1]
			newLines.append( (line, params) )
		self.lines = newLines
	
class UserInterface(SubjectsObserver):
	def __init__(self, subjects = []):
		SubjectsObserver.__init__(self)
		
		if (logLevel <= LOG_NONE):
			self.loggerWindowHeight = 0
		elif (logLevel <= LOG_WARNING):
			self.loggerWindowHeight = 2
		else:
			self.loggerWindowHeight = 5
		
		self._colors = {}
		self.__lock = threading.Lock()
		
		self.mainWindow = CursesMainWindow()
		self.infoWindow = CursesTextWindow(
					height	= 1,
					width 	= self.mainWindow.width,
					x	= 0,
					y	= 0)
		self.progressWindow = CursesWindow(
					height	= self.mainWindow.height-self.loggerWindowHeight-2,
					width 	= self.mainWindow.width,
					x	= 0,
					y	= 1)
		
		self.loggerHeaderWindow = None
		self.loggerWindow = None
		if (self.loggerWindowHeight > 0):
			self.loggerHeaderWindow = CursesTextWindow(
						height	= 1,
						width 	= self.mainWindow.width,
						x	= 0,
						y	= self.mainWindow.height-self.loggerWindowHeight-1)
			self.loggerWindow = CursesTextWindow(
						height	= self.loggerWindowHeight,
						width 	= self.mainWindow.width,
						x	= 0,
						y	= self.mainWindow.height-self.loggerWindowHeight)
		if curses.has_colors():
			curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
			curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_WHITE)
			curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
			curses.init_pair(4, curses.COLOR_WHITE, curses.COLOR_BLACK)
			curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)
			curses.init_pair(6, curses.COLOR_YELLOW, curses.COLOR_BLACK)
			
			self._colors = {
					'INFO_WINDOW':	curses.color_pair(1),
					'LOG_HEADER':	curses.color_pair(2),
					'SUCCESS':	curses.color_pair(3),
					'NORMAL':	curses.color_pair(4),
					'ERROR':	curses.color_pair(5),
					0:		curses.color_pair(5),
					1:		curses.color_pair(5),
					2:		curses.color_pair(5),
					3:		curses.color_pair(6),
					4:		curses.color_pair(3),
					5:		curses.color_pair(4),
					6:		curses.color_pair(4),
					7:		curses.color_pair(4),
					8:		curses.color_pair(4),
					9:		curses.color_pair(4)
			}
			self.infoWindow.setColor(self._colors['INFO_WINDOW'])
			if self.loggerHeaderWindow:
				self.loggerHeaderWindow.setColor(self._colors['LOG_HEADER'])
		
		if self.loggerHeaderWindow:
			self.loggerHeaderWindow.setLines( [ _('Log messages') ] )
			self.loggerHeaderWindow.refresh()
		
		self.mainWindow.refresh()
		
		self.setSubjects(subjects)
		if self.loggerWindow:
			self.addSubject(logger.getMessageSubject())
			logger.setMessageSubjectLevel(logLevel)
		
		import signal
		signal.signal(signal.SIGWINCH, self.resized)
		
	def resized(self, signo, stackFrame):
		try:
			self.mainWindow.resize()
			self.infoWindow.resize(
					height	= 1,
					width 	= self.mainWindow.width,
					x	= 0,
					y	= 0)
			self.progressWindow.resize(
					height	= self.mainWindow.height-self.loggerWindowHeight-2,
					width 	= self.mainWindow.width,
					x	= 0,
					y	= 1)
			if (self.loggerWindowHeight > 0):
				self.loggerHeaderWindow.resize(
						height	= 1,
						width 	= self.mainWindow.width,
						x	= 0,
						y	= self.mainWindow.height-self.loggerWindowHeight-1)
				self.loggerWindow.resize(
						height	= self.loggerWindowHeight,
						width 	= self.mainWindow.width,
						x	= 0,
						y	= self.mainWindow.height-self.loggerWindowHeight)
		except:
			pass
		try:
			self.subjectsChanged(self.getSubjects())
		except:
			pass
		
	def subjectsChanged(self, subjects):
		for subject in self.getSubjects():
			if (subject.getClass() == 'MessageSubject'):
				self.messageChanged(subject, subject.getMessage())
		self.showProgress()
	
	def progressChanged(self, subject, state, percent, timeSpend, timeLeft, speed):
		self.showProgress()
	
	def messageChanged(self, subject, message):
		if self.__lock.locked():
			return
		if subject.getType() is 'Logger':
			self.__lock.acquire()
			try:
				# Do not log anything to avoid log loops !!!
				params = []
				ll = subject.getSeverity()
				if self._colors.has_key(ll):
					params = [ self._colors[ll] ]
				self.loggerWindow.addLines(message.split('\n'), *params)
				self.loggerWindow.refresh()
			finally:
				self.__lock.release()
		
		elif subject.getId() in ('info', 'transfers'):
			self.__lock.acquire()
			try:
				info = ''
				transfers = ''
				for subject in self.getSubjects():
					if subject.getId() is 'info':
						info = subject.getMessage()
					elif subject.getId() is 'transfers':
						transfers = subject.getMessage()
				free = self.infoWindow.width - len(info) - len(transfers) -1
				if (free < 0):
					free = 0
				self.infoWindow.setLines( [ info + ' '*free + transfers ] )
				self.infoWindow.refresh()
			finally:
				self.__lock.release()
		else:
			self.showProgress()
		
	def exit(self):
		for subject in self.getSubjects():
			subject.detachObserver(self)
		self.exitScreen()
	
	def exitScreen(self):
		logger.debug("UserInterface: exitScreen()")
		self.mainWindow = None
	
	def showProgress(self):
		if self.__lock.locked():
			return
		self.__lock.acquire()
		try:
			subjects = {}
			for s in self.getSubjects():
				if (s.getType() == 'depot'):
					subjects[s.getId()] = s
			for s in self.getSubjects():
				if (s.getType() == 'upload'):
					subjects[s.getId()] = s
			ids = subjects.keys()
			ids.sort()
			maxIdLength = 0
			for id in ids:
				if (len(id) > maxIdLength):
					maxIdLength = len(id)
			
			y = 0
			for id in ids:
				subject = subjects[id]
				if (y >= self.progressWindow.height):
					# Screen full
					logger.info("Screen to small to display all progresses")
					break
				
				self.progressWindow.move(y, 0)
				self.progressWindow.clrtoeol()
				
				idString = '%-*s | ' % (maxIdLength, subject.getId())
				if (len(idString) > self.progressWindow.width):
					idString = idString[:self.progressWindow.width]
				self.progressWindow.addstr(idString, curses.A_BOLD)
				
				if (len(idString) < self.progressWindow.width):
					color = None
					self.progressWindow.move(y, len(idString))
					maxSize = self.progressWindow.width - len(idString)
					message = ''
					if subject.getClass() is 'ProgressSubject':
						minutesLeft = str(int(subject.getTimeLeft()/60))
						secondsLeft = str(int(subject.getTimeLeft()%60))
						if (len(minutesLeft) < 2): minutesLeft = '0' + minutesLeft
						if (len(secondsLeft) < 2): secondsLeft = '0' + secondsLeft
						
						message = subject.getMessage()
						progress = ' %8s' % ("%.2f" % subject.getPercent() + '% ') \
							+ '%8s KB' % (subject.getState()/1024) \
							+ '%6s KB/s' % (int(subject.getSpeed()/1024)) \
							+ '%6s:%s ETA' % (minutesLeft, secondsLeft)
						
						free = maxSize - len(message) - len(progress)
						if (free < 0): free = 0
						message = message + ' '*free + progress
					
					elif subject.getClass() is 'MessageSubject':
						severity = subject.getSeverity()
						if severity and self._colors.has_key(severity):
							color = self._colors[severity]
						message = subject.getMessage()
						
					if (len(message) > maxSize):
						message = message[:maxSize]
					if color:
						self.progressWindow.addstr(message, color)
					else:
						self.progressWindow.addstr(message)
				y += 1
			
			while (y < self.progressWindow.height):
				y += 1
			#	self.progressWindow.move(y, 0)
			#	self.progressWindow.clrtoeol()
			
			self.progressWindow.refresh()
			
		finally:
			self.__lock.release()

	
def printHelp():
	print \
	'''
Usage: %s [options] <command>

Manage opsi packages

Commands:
  -i, --install     <opsi-package> ...      install opsi packages
  -u, --upload      <opsi-package> ...      upload opsi packages to repositories
  -l, --list        <regex>                 list opsi packages matching regex
  -D, --differences <regex>                 show depot differences of opsi packages matching regex
  -r, --remove      <opsi-product-id> ...   uninstall opsi packages
  -x, --extract     <opsi-package> ...      extract opsi packages to local directory
  -V, --version                             show program's version info and exit
  -h, --help                                show this help message and exit

Options:
  -d, --depots      <depots>      comma separated list of depots to process
                                  this feature is not supported in the opsi community edition!
                                      (default: %s)
                                      use keyword ALL to process all known depots
  -p, --properties  <mode>        mode for default product property values
                      ask             display dialog
                      package         use defaults from package
                      keep            keep depot defaults (default)
  -f, --force                     force install/uninstall (use with extreme caution)
  -U, --update                    set action "update" on hosts where installation status is "installed"
  -S, --setup                     set action "setup" on hosts where installation status is "installed"
  --max-transfers   <num>         maximum number of simultaneous uploads
                                      0=unlimited (default)
  -o, --overwrite                 overwrite existing package even if size matches
  -k, --keep-files                do not delete client data dir on uninstall
  -t, --temp-dir    <path>        tempory directory for package install
  --interface       <type>        type of user interface
                      text            text based interface
                      snack           newt interface (default)
  -v, --verbose                   increase verbosity (can be used multiple times)
  -q, --quiet                     do not display any messages
  --log-file        <log-file>    path to debug log file
	''' % (os.path.basename(sys.argv[0]), socket.getfqdn())
#  --max-bandwidth   <kbps>        maximum transfer rate for each transfer (in kilobytes per second)
#                                      0=unlimited (default)
def printVersion():
	print "%s %s" % (os.path.basename(sys.argv[0]), __version__)

def main(argv):
	os.umask(0027)
	
	global opm
	global logLevel
	
	#logger.setLogFile('/tmp/log')
	#logger.setFileLevel(LOG_DEBUG)
	
	parser = OptionParser( add_help_option = False )
	
	parser.add_option("-h", "--help",           action="store_true", dest="help")
	parser.add_option("-V", "--version",        action="store_true", dest="version")
	parser.add_option("-v", "--verbose",        action="count",      dest="verbose")
	parser.add_option("-q", "--quiet",          action="store_true", dest="quiet")
	parser.add_option("-i", "--install",        action="store_true", dest="COMMAND_INSTALL")
	parser.add_option("-u", "--upload",         action="store_true", dest="COMMAND_UPLOAD")
	parser.add_option("-p", "--properties",     action="store",      dest="properties",   default="keep", choices=['ask', 'package', 'keep'])
	parser.add_option(      "--max-transfers",  action="store",      dest="maxTransfers", default = 0,    type="int")
	parser.add_option(      "--max-bandwidth",  action="store",      dest="maxBandwidth", default = 0,    type="int")
	parser.add_option("-l", "--list",           action="store_true", dest="COMMAND_LIST")
	parser.add_option("-D", "--differences",    action="store_true", dest="COMMAND_DIFFERENCES")
	parser.add_option("-r", "--remove",         action="store_true", dest="COMMAND_REMOVE")
	parser.add_option("-x", "--extract",        action="store_true", dest="COMMAND_EXTRACT")
	parser.add_option("-d", "--depots",         action="store",      dest="depots")
	parser.add_option("-f", "--force",          action="store_true", dest="force")
	parser.add_option("-k", "--keep-files",     action="store_true", dest="keepFiles")
	parser.add_option("-t", "--temp-dir",       action="store",      dest="tempDir")
	parser.add_option("-o", "--overwrite",      action="store_true", dest="overwriteAlways")
	parser.add_option("-S", "--setup",          action="store_true", dest="setupWhereInstalled")
	parser.add_option("-U", "--update",         action="store_true", dest="updateWhereInstalled")
	parser.add_option(      "--interface",      action="store",      dest="interface",    default="snack", choices=['text', 'snack'])
	parser.add_option(      "--log-file",       action="store",      dest="logFile")
	
	(options, args) = parser.parse_args()
	
	if options.help:
		printHelp()
		sys.exit(0)
	
	if options.version:
		printVersion()
		sys.exit(0)
	
	if options.logFile:
		if os.path.exists(options.logFile):
			os.unlink(options.logFile)
		logger.setLogFile(options.logFile)
		logger.setFileLevel(LOG_DEBUG2)
	
	if (options.properties == 'ask') and options.quiet:
		print >> sys.stderr, _("You cannot use properties=ask in quiet mode")
		sys.exit(1)
	
	if options.quiet:
		options.interface = 'dummy'
		logLevel = LOG_NONE
	elif options.verbose:
		logLevel = LOG_WARNING
		logLevel += options.verbose
	
	cmds = 0
	for cmd in (	options.COMMAND_INSTALL, options.COMMAND_UPLOAD, options.COMMAND_LIST, \
			options.COMMAND_REMOVE, options.COMMAND_EXTRACT, options.COMMAND_DIFFERENCES ):
		if not cmd:
			continue
		cmds += 1
	if (cmds > 1):
		print >> sys.stderr, _("More than one command specified")
		sys.exit(1)
	elif (cmds < 1):
		print >> sys.stderr, _("No command specified")
		sys.exit(1)
	
	packageFiles = []
	productRegex = re.compile('.*')
	productIds = []
	if options.COMMAND_INSTALL or options.COMMAND_UPLOAD or options.COMMAND_EXTRACT:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi package given!")
			sys.exit(1)
		
		for p in args:
			p = os.path.abspath(p)
			if not os.path.exists(p):
				print >> sys.stderr, _("Package file '%s' does not exist!") % p
				sys.exit(1)
			packageFiles.append(p)
		
	elif options.COMMAND_LIST or options.COMMAND_DIFFERENCES:
		if args:
			if (len(args) > 1):
				printHelp()
				sys.exit(1)
			productRegex = re.compile(args[0])
		
	elif options.COMMAND_REMOVE:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi product id given!")
			sys.exit(1)
		productIds = args
	
	depotIds = []
	if not options.COMMAND_EXTRACT:
		bm = BackendManager(authRequired=False)
		depotIds = [ socket.getfqdn() ]
		if options.depots:
			if (options.depots.lower() == 'all'):
				depotIds = bm.getDepotIds_list()
			else:
				depotIds = options.depots.lower().split(',')
				knownDepotIds = bm.getDepotIds_list()
				for depotId in depotIds:
					if depotId not in knownDepotIds:
						raise Exception("Depot '%s' not in list of known depots: %s" \
							% (depotId, ', '.join(knownDepotIds)))
		# Eliminate duplicates
		newDepotIds = []
		for depotId in depotIds:
			if depotId in newDepotIds:
				continue
			newDepotIds.append(depotId)
		depotIds = newDepotIds
	
	if options.COMMAND_DIFFERENCES and (len(depotIds) <= 1):
		print >> sys.stderr, _("More than one depot id needed to display differences")
		sys.exit(1)
	
	try:
		opm = OpsiPackageManager()
		
		opm.forceInstall = opm.forceUninstall = options.force
		opm.uiType = options.interface
		opm.setQuiet(options.quiet)
		opm.maxTransfers = options.maxTransfers
		opm.maxBandwidth = options.maxBandwidth*1024
		opm.deleteFilesOnUninstall = not options.keepFiles
		opm.overwriteAlways = options.overwriteAlways
		opm.setupWhereInstalled = options.setupWhereInstalled
		opm.updateWhereInstalled = options.updateWhereInstalled
		
		# Command EXTRACT
		if options.COMMAND_EXTRACT:
			destination = os.path.abspath(os.getcwd())
			for p in packageFiles:
				opm.extractPackage(p, destination)
			return
		
		# Command INSTALL
		if options.COMMAND_INSTALL:
			if (options.properties == 'ask'):
				opm.keepDefaultProductProperties = False
				opm.productPropertiesDialog(packageFiles)
			elif (options.properties == 'keep'):
				opm.keepDefaultProductProperties = True
			elif (options.properties == 'package'):
				opm.keepDefaultProductProperties = False
			
			if not options.depots:
				# Direct install without upload
				for p in packageFiles:
					opm.installPackage(p, depotIds[0], tempDir=options.tempDir)
			else:
				opm.installOnDepots(packageFiles, depotIds, tempDir=options.tempDir)
		
		# Command UPLOAD
		elif options.COMMAND_UPLOAD:
			opm.uploadToRepositories(packageFiles, depotIds)
		
		# Command REMOVE
		elif options.COMMAND_REMOVE:
			opm.uninstallOnDepots(productIds, depotIds)
		
		# Command LIST
		elif options.COMMAND_LIST:
			info = opm.getProductInformationsFromDepots(depotIds)
			opm.cleanup()
			
			terminalWidth = 60
			try:
				tty = os.popen('tty').readline().strip()
				fd = open(tty)
				terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
				fd.close()
			except:
				pass
			indent = "   "
			idWidth = versionWidth = int((terminalWidth-len(indent))/3)
			if (idWidth > 25): idWidth = 25
			if (versionWidth > 25): versionWidth = 25
			descriptionWidth = terminalWidth-len(indent)-idWidth-versionWidth-4
			
			for (depotId, productInfo) in info.items():
				print "-"*(len(depotId)+4)
				print "- %s -" % depotId
				print "-"*(len(depotId)+4)
				print "%s%*s %*s %*s" % (indent, -1*idWidth, _('Product ID'),
							-1*versionWidth, _('Version'),
							-1*descriptionWidth, _('Description'))
				print "%s%s" % (indent, "="*(terminalWidth-len(indent)-2))
				productIds = productInfo.keys()
				productIds.sort()
				for productId in productIds:
					if not re.search(productRegex, productId):
						continue
					product = productInfo[productId]
					print "%s%*s %*s %*s" % (indent, -1*idWidth, productId,
							-1*versionWidth, product.get('productVersion', '') + '-' + product.get('packageVersion', ''),
							-1*descriptionWidth, product.get('description', '').replace('\n', '')[:descriptionWidth])
				print ""
		
		# Command DIFFERENCES
		elif options.COMMAND_DIFFERENCES:
			infos = opm.getProductInformationsFromDepots(depotIds)
			opm.cleanup()
			
			products = {}
			for (depotId, productInfo) in infos.items():
				productIds = productInfo.keys()
				productIds.sort()
				for productId in productIds:
					if not re.search(productRegex, productId):
						continue
					if not productId in products.keys():
						products[productId] = {
							'productVersion': None,
							'packageVersion': None
					}
				
			maxWidth = 0
			for depotId in depotIds:
				if (len(depotId) > maxWidth):
					maxWidth = len(depotId)
			
			for productId in products.keys():
				differs = False
				lines = []
				lines.append(productId)
				for (depotId, productInfo) in infos.items():
					lines.append( "    %*s: " % (-1*maxWidth, depotId) )
					product = productInfo.get(productId)
					if not product:
						lines[-1] += " not installed"
						differs = True
						continue
					if not products[productId]['productVersion']:
						products[productId]['productVersion'] = product.get('productVersion')
					elif (products[productId]['productVersion'] != product.get('productVersion')):
						differs = True
					
					if not products[productId]['packageVersion']:
						products[productId]['packageVersion'] = product.get('packageVersion')
					elif (products[productId]['packageVersion'] != product.get('packageVersion')):
						differs = True
					lines[-1] += " %s-%s" % (product.get('productVersion'), product.get('packageVersion'))
						
				if differs:
					for line in lines:
						print line
					print ""
		
		opm.cleanup()
		
	except Exception, e:
		if opm:	opm.cleanup()
		raise
	
	while(threading.activeCount() > 1):
		time.sleep(1)
	
	errors = opm.getErrors()
	if errors:
		print >> sys.stderr, _("Errors occured: ")
		for (name, errs) in errors.items():
			logger.error("Failure while processing %s:" % name)
			print >> sys.stderr, "   Failure while processing %s:" % name
			for err in errs:
				logger.error("      %s" % err)
				print >> sys.stderr, "      %s" % err
		sys.exit(1)
	

def signalHandler(signo, stackFrame):
	if (signo == SIGTERM or signo == SIGINT):
		logger.notice("Got signal %s, exiting" % signo)
		if opm and not opm.aborted:
			logger.notice("Aborting opsi package manager")
			opm.abort()
		
	else:
		logger.notice("Got signal %s" % signo)
	
if (__name__ == "__main__"):
	logger.setLogFile('/tmp/log')
	logger.setFileLevel(LOG_NOTICE)
	if (os.name == 'posix'):
		from signal import *
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		#signal(SIGHUP, signalHandler)
		signal(SIGTERM, signalHandler)
		signal(SIGINT, signalHandler)
	
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		sys.exit(int(str(e)))
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, _("ERROR: ") + str(exception)
		sys.exit(1)
	
	sys.exit(0)



