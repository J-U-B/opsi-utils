#!/bin/bash 
#
#  Patchprogramm fuer Microsoft Windows .INI Dateien
#   Dez. 94  - G. Weick
#  Aenderungen:
#   12.1.95  - ignoriert vorstehende und anhaengende Leerzeichen
#              G. Weick
#
#   3.7.95   - addgrp Kommando um neue Gruppen in die progman.ini
#              einzuführen.   D. Oertel
#   15.8.95  - addgrp fuegt die selbe Gruppe nicht nochmals in eine
#              progman.ini ein.   D. Oertel
#   28.8.95  - Version 1 fuer Unix G.Weick
#   20.9.95  - addnew traegt Eintrag ein wenn er komplett noch nicht
#              vorhanden war (wie vorher add)
#              add traegt Eintrag nur noch ein wenn der vordere Teil nicht
#              vorhanden ist   D. Oertel
#   20.9.96  - delsec entfernt eine ganze Sektion. G.Weick
#            - del loescht auch einen Eintrag, wenn im del-Kommando
#              kein Gleichheitszeichen vorkommt, ein bis zum Gleichheitszeichen
#              entsprechender Eintrag aber in der Ini-Datei existiert.
#   17.1.97  - change aendert einen vorhanden Eintrag wenn er im angegebenen
#              Bereich bis zum Gleichheitszeichen existiert.
#            - replace tauscht Eintraege unabhaengig vom Bereich aus. D. Oertel
#   20.2.97  - geteintr() ignoriert Leerzeichen vor und nach dem ersten
#              Gleichheitszeichen    D. Oertel
#   20.10.97 - Pruefung auf DOS/Unix Text eingefuegt.
#    4.2.98  - Bugfix, Warnung nur bei DEBUG
#    1.7.98  - anpassung to_unix statt dos2unix fuer SGI
#   22.7.98  - Option -v eingebaut
#   12.1.99  - gawk eingebaut, PATH angepasst, Bugfix fuer fast leere
#              Zeilen in der Patchdatei.
#   24.3.2000 - Unterschiede beim Quoting (Solaris/Linux) bereinigt.
#   11.2.2002 - mit Option -c bzw. -C werden nun auch Ini-Dateien erzeugt.
#    7.9.2004 - sucht jetzt brauchbaren awk, der nicht gawk heissen muss
#             - Zusaetzliche Syntaxpruefung in den Kommandos eingefuehrt

LANG=C
PATH=/bin:/usr/bin:/sbin:/usr/sbin:/opt/bin
IFS=' '

# erstelle AWK Variable mit dem "richtigen" awk Programm
if [ -x "`which gawk`" ] ; then AWK=gawk
    else if [ -x "`which nawk`" ]  ; then AWK=nawk
       else AWK=awk
   fi
fi
# Teste, ob die Faehigkeiten des gefundenen AWK ausreichen
$AWK -v t=test 'BEGIN {exit}'
if [ "$?" != 0 ] ; then
  echo "Ihr awk Program $AWK kann leider die Posix Erweiterungen 1003.2"
  echo "Vermutlich ist es steinalt. $0 wird daher beendet"
  exit 1
fi 

export AWK LANG

usage()
{   echo "Aufruf: $PNAME [--] -v "
    echo "$PNAME gibt Versionskennung aus."
    echo
    echo "Aufruf: $PNAME [-c|-C] {-f Patch-Datei | Patch-Kommandos} [ Inidateien ]"
    echo "$PNAME aendert eine Datei im Windows-INI-Format."
    echo "       mit -c wird eine Ini-datei im Unix Text Format erzeugt,"
    echo "       auch wenn die Datei nicht existiert oder leer ist."
    echo "       mit -C wird eine Ini-datei im DOS Text Format erzeugt,"
    echo "       auch wenn die Datei nicht existiert oder leer ist."
    echo
    echo "Das Format fuer die Patch-Datei bzw. Patch-Kommandos ist:"
    echo "    add [Bereich]  Eintrag"
    echo "    del [Bereich]  Eintrag"
    echo "    set [Bereich]  Eintrag"
    echo "    addnew [Bereich]  Eintrag"
    echo "    change [Bereich]  Eintrag"
    echo "    delsec [Bereich]"
    echo "Nur fuer PROGMAN.INI:"
    echo "    addgrp [Groups]  Neuegruppe"
    echo "    ....."
    echo 
    echo "Wird keine Ini-Datei angegeben, so wird von stdin gelesen."
    echo "und nach stdout ausgegeben. Ansonsten werden die als Parameter"
    echo "angegeben INI-Dateien geaendert."
    echo
    exit 1
}

file_typ()
# Parameter Dateiname
{   cat $1 | $AWK '
    {  if (substr($0, length($0),1) == sprintf("%c",13))
          printf("dostext\n");
       else printf("unixtext\n");
       exit;
    }'
}
        
make_dos2unix2dos()
# erzeugt betriebspezifische Variablen fuer dos2unix und unix2dos
{  if [ `uname -s` = IRIX64 ] ; then
      DOSTOUNIX="to_unix"
      UNIXTODOS="to_dos"
   else
      if [ `uname -s` = Linux ] ; then
         DOSTOUNIX="recode ibmpc..lat1"
         UNIXTODOS="recode lat1..ibmpc"
      else
         if [ `uname -s` = SunOS ] ; then
            DOSTOUNIX="dos2unix -437"
            UNIXTODOS="unix2dos -437"
         else
            DOSTOUNIX=cat
            UNIXTODOS=cat
         fi
      fi
   fi
}

winipatchfunc()
{  $AWK -v INPUT=/tmp/$PNAME.input.$$ '

   function delblanks(s)
   # Loescht vorstehende und ahaengende Lerrzeichen eines Strings
   {    while (((len = length(s)) > 0 ) && ((substr(s,1,1) == " ") || (substr(s,1,1) == "\t")))
           s = substr(s, 2, len - 1);
        while (((len = length(s)) > 0 ) && (substr(s,len,1) == " " || substr(s,len,1) == "\t"))
           s = substr(s, 1, len -1);
        return(s);
   }

   function getBereich(pBereich)
   #  Gibt die Bereichsnummer des uebergebenen Strings zurueck, sonst 0
   {
      for ( i = 1; i <= AnzBer; ++i)
        if (toupper(Bereich[i]) == toupper(pBereich)) return (i);
      return(0);
   }

   function getEintrag(b, peintr)
   # Gibt die Eintragsnummer des uebergebenen Strings zurueck, sonst 0
   {
      for (i=1; i <= AnzEin[b]; ++i)
	  {
	   sheintr =  substr(Eintrag[b, i], 1, index(Eintrag[b, i], "=")-1);
       endeintr = substr(Eintrag[b, i], index(Eintrag[b, i], "=")+1,length(Eintrag[b,i]));
       pendeintr = substr(peintr, index(peintr, "=")+1,length(peintr));
	   fronteintr = substr(peintr, 1, index(peintr, "=")-1);
	   peintr = sprintf("%s=%s",delblanks(fronteintr),delblanks(pendeintr));
	   eintr = sprintf("%s=%s",delblanks(sheintr),delblanks(endeintr));
       if (delblanks(toupper(eintr)) == delblanks(toupper(peintr))) return(i);
 	 }
     return(0);
   }


   function getfrontEintrag(b, peintr)
   # wie getEintrag nur das nur der Teil bis zum Gleichheitszeichen des
   # Eintrags verglichen wird
   {
      for (i=1; i <= AnzEin[b]; ++i)
      {    sheintr = substr(Eintrag[b, i], 1, index(Eintrag[b, i], "=")-1);
           fronteintr = substr(peintr, 1, index(peintr, "=")-1);
           if (delblanks(toupper(sheintr)) == delblanks(toupper(fronteintr)))
           return(i);
      }
      return(0);
   }


   function getshEintrag(b, peintr)
   # wie getEintrag nur das nur der Teil bis zum Gleichheitszeichen des
   # Eintrags uebergeben wird
   {
      for (i=1; i <= AnzEin[b]; ++i)
      {    sheintr = substr(Eintrag[b, i], 1, index(Eintrag[b, i], "=")-1);
           if (delblanks(toupper(sheintr)) == delblanks(toupper(peintr)))
           return(i);
      }
      return(0);
   }
   
   function getEndEintrag(b, peintr)
   # wie getEintrag nur das nur der Teil nach dem Gleichheitszeichen des
   # Eintrags uebergeben wird
   {
      for (i=1; i <= AnzEin[b]; ++i)
      {    endeintr = substr(Eintrag[b, i], index(Eintrag[b, i], "=")+1,length(Eintrag[b,i]));
           if (delblanks(toupper(endeintr)) == delblanks(toupper(peintr)))
           return(i);
      }
      return(0);
   }
   

   function addnew(ber, eintr)
   # Fuegt einen Eintrag in einen Bereich ein, falls er noch nicht existiert
   # Falls der Bereich noch nicht da ist wird er erstellt.
   {  b = getBereich(ber);
      e = getEintrag(b, eintr);
      if ( b == 0)
      {  ++AnzBer;
         Bereich[AnzBer] = ber;
         AnzEin[AnzBer] = 1;
         Eintrag[AnzBer,1] = eintr;
      }
      else
      {   if ( e == 0)
          {  ++AnzEin[b];
             Eintrag[b, AnzEin[b]] =  eintr;
          }
          else if (debug)
             printf("Warnung: Eintrag %s im Bereich %s bereits vorhanden!\n",
                         eintr, ber) >> "/dev/stderr"  ;
      }
   }



   function add(ber, eintr)
   # Fuegt einen Eintrag in einen Bereich ein, falls der vordere Teil (bis zum
   # Gleichheitszeichen) noch nicht existiert, sonst wird nichts geschrieben
   # Falls der Bereich noch nicht da ist wird er erstellt.
   {  b = getBereich(ber);
      e = getfrontEintrag(b, eintr);
      fronteintr = substr(eintr, 1, index(eintr, "=")-1);
      if ( b == 0)
      {  ++AnzBer;
         Bereich[AnzBer] = ber;
         AnzEin[AnzBer] = 1;
         Eintrag[AnzBer,1] = eintr;
      }
      else
      {   if ( e == 0)
          {  ++AnzEin[b];
             Eintrag[b, AnzEin[b]] =  eintr;
          }
          else if (debug)
            printf("Warnung: Eintrag %s im Bereich %s bereits vorhanden!\n",
                         fronteintr, ber) >> "/dev/stderr"  ;
      }
   }


   function set(ber, eintr)
   # Setz im Bereich ber den Eintrag eintr.
   # Falls Bereich oder Eintrag nicht existiert wird er erstellt
   # Falls der Eintrag mit anderem Wert nach dem Gleichheitszeichen
   # vorhanden ist, wird er umgesetzt.
   {  b = getBereich(ber);
      e = getshEintrag(b, substr(eintr, 1, index(eintr,"=")-1));
      if ( b == 0)
      {  ++AnzBer;
         Bereich[AnzBer] = ber;
         AnzEin[AnzBer] = 1;
         Eintrag[AnzBer,1] = eintr;
      }
      else
      {   if ( e == 0)
          {  ++AnzEin[b];
             Eintrag[b, AnzEin[b]] =  eintr;
          }
          else Eintrag[b, e] = eintr;
      }
   }
   
   function del(ber, eintr)
   # Loescht einen Eintrag
   {  b = getBereich(ber);
      e = getEintrag(b, eintr);
      if (e == 0 && index(eintr,"=") == 0)
         e = getshEintrag(b, eintr);
      if (b != 0)
      {  if (e != 0)
         {   for ( i = e; i < AnzEin[b]; ++i)
               Eintrag[b, i] = Eintrag[b, i+1];
             --AnzEin[b];
          }
         # else  printf("Fehler: Eintrag %s in Bereich %s nicht gefunden!\n" ,
         #           eintr, ber)  >> "/dev/stderr" ;
       }
       # else  printf("Fehler: Bereich %s nicht gefunden!\n" ,
       #              ber)  >> "/dev/stderr" ;
   }


   function change(ber, eintr)
   # Aendert einen Eintrag nur wenn er bis zum = vorhanden ist
   {  b = getBereich(ber);
      e = getEintrag(b, eintr);
      if (e == 0 && index(eintr,"=") == 0)
         e = getshEintrag(b, eintr);
      if (b != 0)
      {  if (e != 0)
         {  Eintrag[b, e] = eintr;
         }
       }
   }

   function replace(eintr1,eintr2)
   # ersetzt Eintraege unabhaengig vom Bereich
   { 
    for (b=1; b<=AnzBer; ++b) {
      e = getEintrag(b, eintr1);
      if (e != 0)
      { Eintrag[b, e] = eintr2;
      }
    }
   }
   
   function delsec(ber)
   # Loescht einen Bereich
   {  b = getBereich(ber);
      if (b != 0) {
        for (i=b+1; i<=AnzBer; ++i) {
           Bereich[i-1]=Bereich[i];
           for (k=1; k<=AnzEin[i]; ++k) Eintrag[i-1,k] =Eintrag[i,k];
           AnzEin[i-1] = AnzEin[i];
        }
        --AnzBer;
      }
   #   else  printf("Fehler: Bereich %s nicht gefunden!\n" ,
   #                  ber)  >> "/dev/stderr" ;
   }
   
   function addgrp(dummy,newgroup)
   # neuer Gruppeneintrag fuer progman.ini
   {
    orderbereich = getBereich("[Settings]");
    groupbereich = getBereich("[Groups]");
    if (! orderbereich || ! groupbereich)
    {
     printf("INI-Datei war keine ordentliche PROGMAN.INI !\n") >> "/dev/stderr";
     printf(" -> Patchvorgang abgebrochen ! \n") >> "/dev/stderr";
     return(0);
    }
    # Achtung Gruppennr in prorman.ini ist 1 niedriger als groupnr
    groupnrexist = 1;
    groupexist = 0;
    for (groupnr=1;groupnrexist != 0;groupnr++)
    {
     greintrag=sprintf("Group%d",groupnr);
     groupnrexist=getshEintrag(groupbereich,greintrag);
     if (getEndEintrag(groupbereich,newgroup))
      groupexist=1;
      existnr=sprintf("Group%d",groupnr-1);
    }
    if (! groupexist)
    {
     newgrpeintrag = sprintf("%s=%s",greintrag,newgroup);
     add("[Groups]",newgrpeintrag);
     oldorder=getshEintrag(orderbereich,"Order");
     neworder=sprintf("%s %d",Eintrag[orderbereich,oldorder],--groupnr);
     set("[Settings]",neworder);
    }
    else if (debug)
     printf("winiptch: Warnung: Gruppe %s war schon als %s eingetragen.\n",
             newgroup, existnr) >> "/dev/stderr" ;
   }

   # Einlesen der INI-Datei

   BEGIN  {  AnzBer = 0; Bereich[AnzBer]="";  
             debug=(ENVIRON["DEBUG"] == "on");
             while (x = getline < INPUT ) {
                if (NF != 0 )  {
                   if (substr($1,1,1) == "[")
                   {   ++AnzBer;
                        AnzEin[AnzBer] = 0;
                        Bereich[AnzBer] = substr($0, 1 ,index($0,"]"));
                   }
                   else
                   {  ++AnzEin[AnzBer];
                      Eintrag[AnzBer,AnzEin[AnzBer]] =  $0;
                   }
                }
             }
          }

   #  Einlesen der Patch-Datei

   {  if (NF >= 3)
      {  COMMAND=toupper($1);
         rest=substr($0, length(COMMAND) +1);
         while ((c = substr(rest,1,1)) == " " || c == "\t")
             rest = substr(rest,2, length(rest)-1);
         lKeck=index(rest,"[");
         rKeck=index(rest, "]");
         if (lKeck == 0 || rKeck == 0) {
            printf("Sektion fehlt in Zeile\n\t%s\n", $0) >"/dev/stderr";
            next;
         }            
         ber = substr(rest, lKeck, rKeck +1 - lKeck);
         eintr =  substr(rest,rKeck+1,length(rest)-rKeck);
         while ((c = substr(eintr,1,1)) == " " || c == "\t")
             eintr = substr(eintr,2, length(eintr)-1);
         if (COMMAND == "ADD")  add(ber, eintr);
         else if (COMMAND == "DEL") del(ber,eintr);
         else if (COMMAND == "SET") set(ber,eintr);
         else if (COMMAND == "ADDGRP") addgrp(ber,eintr);
         else if (COMMAND == "DELSEC") delsec(ber);
         else if (COMMAND == "ADDNEW") addnew(ber,eintr);
         else if (COMMAND == "CHANGE") change(ber,eintr);
         else if (COMMAND == "REPLACE") {
                  eintr1 = $2;
                  eintr2 = $3;
                  replace(eintr1,eintr2);
                 }
         else printf ("Fehler: Kommando %s unbekannt!\n", $1) >> "/dev/stderr" ;
      }
      else {
         if (NF == 2) {
            ber = substr($0,index($0,"["),index($0, "]") +1 - index($0,"["));
            if (toupper($1) == "DELSEC") delsec(ber);
            else printf ("Fehler: Kommando %s unbekannt!\n", $1) >> "/dev/stderr" ;
         }
         else if (NF > 0 && substr($0,1,1) != "#")
            printf("Fehler: Zeile kann nicht interpretiert werden:\n\t%s\n",
                  $0) >> "/dev/stderr" ;
      }
   }

   # Ausgabe

   END {  for (b=0; b<=AnzBer; ++b)
          {   print Bereich[b];
              for (e = 1; e <= AnzEin[b]; ++e)
                 printf("%s\n", Eintrag[b, e]);
              printf("\n");
          }
       }  '
}


####  Hauptprogramm

CREATE=no
PNAME=`basename $0`
VERSION="$PNAME Version 3.8 6.9.2004 (c) G.Weick"
for i in $* ; do
   case "$i" in -- ) shift;;
                -c ) CREATE=unix; shift;;
                -C ) CREATE=dos; shift;;
                -v ) echo "$VERSION"; exit ;;
   esac
done

INIFILES=""
if [ "$1" = "-h" ] ; then usage ; fi
if [ "$1" = "-f" ] ; then
    shift
    # Input-File
    if [ -z "$1" ] ; then 
       # Patch-Datei vergessen
       usage
    else
       # Patch-Datei ist dritter Parameter
       Input=File
       PATCHFILE=$1
    fi
else
    #  Input steht als Parameter hinter dem Programmnamen
    Input=Parameter
    PATCHPARAM="$1"
fi

FILES=       
if [ "$2" = "-" ] ; then
   # Ini-Datei von stdin
   STDIN=true
   cat > /tmp/$PNAME.$$
   FILES=/tmp/$PNAME.$$
else
   #  Ini-Dateien sind angegeben als Parameter
   STDIN=false
   while [ -n "$2" ] ; do
      FILES="$FILES $2"
      shift
   done
fi
      
for f in $FILES ; do   
  if [ "$STDIN" = "true" ] ; then INPUTFILE=STDIN ; else INPUTFILE=$f; fi
  FILEOK=unknown
  if [ ! -s "$f" ] ; then
     # Ini-Datei hat die Groesse 0 oder existiert nicht.
     if [ "$CREATE" = unix ] ; then
        DOSTOUNIX=cat
        UNIXTODOS=cat
        FILEOK=yes
        cat /dev/null > /tmp/$PNAME.input.$$
     else 
        if [ "$CREATE" = dos ] ; then
           make_dos2unix2dos
           FILEOK=yes
           cat /dev/null > /tmp/$PNAME.input.$$
        else
           # Alte Ini-Datei wird wiederhergestellt
           echo "Fehler: Datei $INPUTFILE existiert nicht oder hat die Groesse 0." >&2
           echo "Nichts geaendert." >&2
        FILEOK=no
        fi
     fi
  else
     # Teste ob DOS oder Unix text
     FILEOK=yes
     if [ `file_typ $f` != dostext ] ; then 
        DOSTOUNIX=cat
        UNIXTODOS=cat
     else
        make_dos2unix2dos
     fi
     cat $f | $DOSTOUNIX > /tmp/$PNAME.input.$$
  fi
  if [ "$FILEOK" = yes ] ; then
     # Jetzt wird gepatcht
     if [ "$Input" = "File" ] ; then
        cat $PATCHFILE | winipatchfunc | $UNIXTODOS > $f
     else if [ "$Input" = "Parameter" ] ; then
          export PATCHPARAM
          $AWK ' BEGIN  { print ENVIRON["PATCHPARAM"];
                         exit }' | winipatchfunc | $UNIXTODOS > $f
       fi
     fi
     rm /tmp/$PNAME.input.$$
  fi
done

if [ "$f" = /tmp/$PNAME.$$ ] ; then 
   # Datei kam von stdin
   cat $f
   rm $f 
fi

if [ -s /tmp/$PNAME.err.$$ ] ; then
    cat /tmp/$PNAME.err.$$ >&2 
    rm /tmp/$PNAME.err.$$  
fi
    

