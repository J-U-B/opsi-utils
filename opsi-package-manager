#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys, os, mimetools, base64, re, stat, socket, threading, time, fcntl
from optparse import OptionParser, IndentedHelpFormatter
from twisted.web2 import responsecode
from twisted.web2.dav import davxml
from httplib import HTTPConnection, HTTPSConnection
import urllib

from OPSI.Backend.Backend import *
from OPSI.Backend.BackendManager import BackendManager
from OPSI.Backend.JSONRPC import JSONRPCBackend
from OPSI.Logger import *
from OPSI.Product import *
from OPSI import Tools
from OPSI.UI import *

__version__ = '0.1'

logger = Logger()
logLevel = LOG_NONE
logger.setConsoleLevel(logLevel)
logger.setConsoleColor(True)

# Get locale
try:
	t = gettext.translation('opsi_????', LOCALE_DIR)
	def _(string):
		return t.ugettext(string).encode('utf-8', 'replace')
	
except Exception, e:
	logger.error("Locale not found: %s" % e)
	def _(string):
		"""Dummy method, created and called when no locale is found.
		Uses the fallback language (called C; means english) then."""
		return string

class TransferProgress:
	def __init__(self, name, size):
		self.name = name
		if (size < 0): size = 0
		self.size = size
		self.percent = 0
		self.state = 0
		self.timeStarted = long(time.time())
		self.timeSpend = 0
		self.timeLeft = 0
		self.timeFired = 0
		self.bytesPerSecond = 0
		self._listener = []
	
	def setState(self, state):
		if (state < 0): state = 0
		if (state > self.size): state = self.size
		self.state = state
		now = long(time.time())
		if (self.timeFired != now) or (state == self.size):
			if (self.size == 0):
				self.percent = 100
			else:
				self.percent = float(100)*(float(self.state) / float(self.size))
			
			self.timeSpend = now - self.timeStarted
			if self.timeSpend:
				self.bytesPerSecond = int(self.state/self.timeSpend)
				self.timeLeft = ((self.size-self.state)/self.bytesPerSecond)
			
			self.timeFired = now
			self.fireProgressChanged()
	
	def addToState(self, x):
		self.setState(self.state + x)
	
	def addListener(self, listener):
		for l in self._listener:
			if (l == listener):
				return
		self._listener.append(listener)
	
	def removeListener(self, listener):
		n = -1
		for i in range(len(self._listener)):
			if (self._listener[i] == listener):
				n = i
				break
		if (n > -1):
			del self._listener[n]
	
	def fireProgressChanged(self):
		for l in self._listener:
			l.progressChanged(self)
	
	
class TransferProgressListener:
	def __init__(self):
		pass
	
	def progressChanged(self, transfer):
		pass
	
class RepositoryError(Exception):
	ExceptionShortDescription = "Repository error"
	
	def __init__(self, message = None):
		self.message = message
	
	def __str__(self):
		#return "<%s: %s>" % (self.__class__.__name__, self.message)
		return str(self.message)
	
	def complete_message(self):
		if self.message:
			return "%s: %s" % (self.ExceptionShortDescription, self.message)
		else:
			return "%s" % self.ExceptionShortDescription

def getRepository(url, username='', password=''):
	if re.search('^file://', url):
		return FileRepository(url, username, password)
	if re.search('^webdavs*://', url):
		return WebDAVRepository(url, username, password)
	raise RepositoryError("Repository url '%s' not supported" % url)
	
class Repository:
	def __init__(self, url, username='', password=''):
		self._url = url
		self._username = username
		self._password = password
		self._path = ''
	
	def _absoluteDestination(self, destination):
		raise RepositoryError("Not implemented")
		
	def content(self, destination=''):
		raise RepositoryError("Not implemented")
		
	def upload(self, source, destination):
		raise RepositoryError("Not implemented")
		
	def delete(self, destination):
		raise RepositoryError("Not implemented")
	
	def fileInfo(self, destination):
		raise RepositoryError("Not implemented")
	
class FileRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^file://(/[^/]+.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		self._path = match.group(1)
	
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def content(self, destination=''):
		destination = self._absoluteDestination(destination)
		try:
			return os.listdir(destination)
		except:
			raise RepositoryError("Not a directory: '%s'" % destination)
	
	def fileInfo(self, destination):
		destination = self._absoluteDestination(destination)
		info = {}
		try:
			fs = os.stat(destination)
			info['size'] = fs[stat.ST_SIZE]
			return info
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
		
	def upload(self, source, destination, progressListener=None):
		
		destination = self._absoluteDestination(destination)
		
		fs = os.stat(source)
		size = fs[stat.ST_SIZE]
		logger.debug("Length of binary data to upload: %d" % size)
		
		transferProgress = TransferProgress(os.path.basename(source) + ' >> ' + self._path, size)
		if progressListener: transferProgress.addListener(progressListener)
		
		(src, dst) = (None, None)
		try:
			src = open(source, 'rb')
			dst = open(destination, 'wb')
			buf = True
			while(buf):
				buf = src.read(32*1024)
				read = len(buf)
				if (read > 0):
					dst.write(buf)
					transferProgress.addToState(read)
			src.close()
			dst.close()
		except Exception, e:
			if src: src.close()
			if dst: dst.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
		
	def delete(self, source, destination):
		destination = self._absoluteDestination(destination)
		os.unlink(destination)
	
class WebDAVRepository(Repository):
	def __init__(self, url, username='', password=''):
		Repository.__init__(self, url, username, password)
		
		match = re.search('^(webdavs*)://([^:]+:*[^:]+):(\d+)(/.*)$', self._url)
		if not match:
			raise RepositoryError("Bad url: '%s'" % self._url)
		
		self._protocol = match.group(1)
		self._host = match.group(2)
		if (self._host.find('@') != -1):
			(username, self._host) = self._host.split('@', 1)
			password = ''
			if (username.find(':') != -1):
				(username, password) = username.split(':', 1)
			if not self._username and username: self._username = username
			if not self._password and password: self._password = password
		self._port = int(match.group(3))
		self._path = match.group(4)
		self._auth = 'Basic '+ base64.encodestring( urllib.unquote(self._username + ':' + self._password) ).strip()
		self._connection = None
		self._cookie = ''
	
	def _absoluteDestination(self, destination):
		if destination.startswith('/'):
			destination = destination[1:]
		return self._path + '/' + destination
	
	def _connect(self):
		logger.debug("WebDAVRepository _connect()")
		if self._protocol.endswith('s'):
			self._connection = HTTPSConnection(self._host, self._port)
		else:
			self._connection = HTTPConnection(self._host, self._port)
		
		self._connection.request("PROPFIND", "/products/", headers = { 'authorization': self._auth, 'depth': '0' })
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to connect to '%s://%s:%s': %s" \
				% (self._protocol, self._host, self._port, response.status))
		# We have to read the response!
		response.read()
		
		# Get cookie from header
		cookie = response.getheader('set-cookie', None)
		if cookie:
			# Store cookie 
			self._cookie = cookie.split(';')[0].strip()
	
	def _getContent(self, destination=''):
		
		content = []
		
		self._connect()
		
		self._connection.putrequest('PROPFIND', destination)
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.putheader('depth', '1')
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.MULTI_STATUS):
			raise RepositoryError("Failed to list dir '%s': %s" \
				% (destination, response.status))
		
		msr = davxml.WebDAVDocument.fromString(response.read())
		if not msr.root_element.children[0].childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer).childOfType(davxml.ResourceType).children:
			raise RepositoryError("Not a directory: '%s'" % destination)
		for child in msr.root_element.children[1:]:
			#<prop>
			#	<resourcetype/>
			#	<getetag>W/"1737A0-373-47DFF2F3"</getetag>
			#	<getcontenttype>text/plain</getcontenttype>
			#	<getcontentlength>883</getcontentlength>
			#	<getlastmodified>Tue, 18 Mar 2008 17:50:59 GMT</getlastmodified>
			#	<creationdate>2008-03-18T17:50:59Z</creationdate>
			#	<displayname>connect.vnc</displayname>
			#</prop>
			pContainer = child.childOfType(davxml.PropertyStatus).childOfType(davxml.PropertyContainer)
			info = { 'size': long(0), 'type': 'file' }
			info['name'] = str(pContainer.childOfType(davxml.DisplayName))
			if (str(pContainer.childOfType(davxml.GETContentLength)) != 'None'):
				info['size'] = long( str(pContainer.childOfType(davxml.GETContentLength)) )
			if pContainer.childOfType(davxml.ResourceType).children:
				info['type'] = 'dir'
			
			content.append(info)
		
		return content
	
	def content(self, destination=''):
		result = []
		destination = self._absoluteDestination(destination)
		for c in self._getContent(destination):
			result.append( c['name'] )
		return result
	
	def fileInfo(self, destination):
		info = {}
		try:
			path = self._absoluteDestination('/'.join(destination.split('/')[:-1]))
			name = destination.split('/')[-1]
			for c in self._getContent(path):
				if (c['name'] == name):
					info['size'] = c['size']
					return info
			raise Exception('file not found')
		except Exception, e:
			raise RepositoryError("Failed to get file info for '%s': %s" % (destination, e))
	
	
	def upload(self, source, destination, progressListener=None):
		destination = self._absoluteDestination(destination)
		src = None
		try:
			fs = os.stat(source)
			size = fs[stat.ST_SIZE]
			logger.debug("Length of binary data to upload: %d" % size)
			
			transferProgress = TransferProgress(os.path.basename(source) + ' >> ' + self._host, size)
			if progressListener: transferProgress.addListener(progressListener)
			
			self._connect()
			
			self._connection.putrequest('PUT', destination)
			
			if self._cookie:
				# Add cookie to header
				self._connection.putheader('cookie', self._cookie)
			self._connection.putheader('authorization', self._auth)
			self._connection.putheader('content-length', size)
			self._connection.endheaders()
			
			src = open(source, 'rb')
			buf = True
			while(buf):
				buf = src.read(32*1024)
				read = len(buf)
				logger.debug2("Read %d bytes" % read)
				if (read > 0):
					self._connection.send(buf)
					transferProgress.addToState(read)
			src.close()
			
			response = self._connection.getresponse()
			if (response.status != responsecode.CREATED) and (response.status != responsecode.NO_CONTENT):
				raise Exception(response.status)
			# We have to read the response!
			response.read()
		except Exception, e:
			logger.logTraceback(e)
			if src: src.close()
			raise RepositoryError("Failed to upload '%s' to '%s': %s" \
						% (source, destination, e))
		logger.debug2("WebDAV upload done")
	
	def delete(self, destination):
		self._connect()
		
		destination = self._absoluteDestination(destination)
		
		self._connection.putrequest('DELETE', destination)
		
		if self._cookie:
			# Add cookie to header
			self._connection.putheader('cookie', self._cookie)
		self._connection.putheader('authorization', self._auth)
		self._connection.endheaders()
		
		response = self._connection.getresponse()
		if (response.status != responsecode.NO_CONTENT):
			raise RepositoryError("Failed to delete '%s': %s" \
				% (destination, response.status))
		# We have to read the response!
		print response.read()
	

class Task():
	def __init__(self, name, opsiPackageManager, method, params):
		self.name = name
		self.opsiPackageManager = opsiPackageManager
		self.method = method
		self.params = params
		if not type(self.params) is tuple:
			self.params = ( self.params )
		self.started = False
		self.ended = False
		self.exception = None
	
	def isRunning(self):
		return self.started and not self.ended
		
	def start(self):
		logger.debug("Task start()")
		self.started = True
		try:
			logger.debug2("Method: %s" % self.method)
			logger.debug2("Params: %s" % str(self.params))
			self.method( *self.params )
		except Exception, e:
			logger.logException(e)
			self.exception = e
			self.ended = True
			raise
		self.ended = True

class UploadTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)
	
	def start(self):
		while self.opsiPackageManager.maxTransfersReached():
			logger.debug("Maximum number transfers reached, waiting")
			time.sleep(1)
		Task.start(self)
		# Sleeping 3 seconds to provide the opportunity to start other upload tasks
		time.sleep(3)
		
class InstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class UninstallTask(Task):
	def __init__(self, name, opsiPackageManager, method, params):
		Task.__init__(self, name, opsiPackageManager, method, params)

class TaskQueue(threading.Thread):
	def __init__(self, name):
		threading.Thread.__init__(self)
		self.name = name
		self.tasks = []
		self.started = False
		self.ended = False
		self.errors = []
		self.currentTaskNumber = -1
	
	def getCurrentTask(self):
		if (self.currentTaskNumber < 0):
			return None
		return self.tasks[self.currentTaskNumber]
	
	def run(self):
		self.currentTaskNumber = -1
		if not self.tasks:
			raise Exception("No tasks in queue")
		self.started = True
		logger.debug("TaskQueue '%s' started" % self.name)
		for task in self.tasks:
			try:
				logger.debug("Starting task '%s'" % task.name)
				self.currentTaskNumber += 1
				task.start()
				logger.debug("Task '%s' ended" % task.name)
			except Exception, e:
				logger.error("Task '%s' failed: %s" % (task.name, e))
				self.errors.append(e)
		self.ended = True
		
		
	def addTask(self, task):
		if not isinstance(task, Task):
			raise ValueError("Task wanted, '%s' passed")
		self.tasks.append(task)

class OpsiPackageManager(TransferProgressListener):
	
	def __init__(self, configBackend):
		if not configBackend:
			raise Exception("No config backend given")
		
		TransferProgressListener.__init__(self)
		
		self.configBackend = configBackend
		self.productPackageFiles = {}
		self.maxTransfers = 0
		self.overwriteIfSizeDiffers = True
		self.overwriteAlways = False
		self.forceInstall = False
		self.keepDefaultProductProperties = True
		self.deleteFilesOnUninstall = True
		self.quiet = True
		self.taskQueues = []
		self.uiType = 'snack'
		self.ui = None
		self.consoleLevelSaved = LOG_NONE
		logger.info("OpsiPackageManager initiated, using config backend '%s'" % self.configBackend)
	
	def openProductPackageFile(self, packageFile):
		if not self.productPackageFiles.has_key(os.path.basename(packageFile)):
			self.productPackageFiles[os.path.basename(packageFile)] = ProductPackageFile(packageFile)
	
	def getProductPackageFile(self, packageFile):
		return self.productPackageFiles.get(os.path.basename(packageFile))
	
	def getDepotConnection(self, depotId):
		depotKey = self.configBackend.getOpsiHostKey(depotId)
		return JSONRPCBackend( username = depotId, password = depotKey, address = depotId )
	
	def getLocalDepotPath(self, depotId):
		depot = self.configBackend.getDepot_hash(depotId)
		localPath = depot['repositoryLocalUrl']
		if not localPath.startswith('file://'):
			raise Exception("Repository local url '%s' not allowed" % localPath)
		localPath = localPath[7:]
		if localPath.endswith('/'):
			localPath = localPath[:-1]
		return localPath
	
	def getRepositoryRemoteURL(self, depotId):
		depot = self.configBackend.getDepot_hash(depotId)
		return depot['repositoryRemoteUrl']
		
	def getNumberOfTransfers(self):
		transfers = 0
		for tq in self.taskQueues:
			ct = tq.getCurrentTask()
			if ct and isinstance(ct, UploadTask) and ct.isRunning():
				transfers += 1
		logger.debug("%d transfers running" % transfers)
		return transfers
	
	def maxTransfersReached(self):
		if self.maxTransfers and (self.getNumberOfTransfers() >= self.maxTransfers):
			return True
		return False
		
	def getErrors(self):
		errors = {}
		for tq in self.taskQueues:
			if not tq.errors:
				continue
			errors[tq.name] = tq.errors
		return errors
	
	def initUi(self):
		if not self.ui:
			self.consoleLevelSaved = logger.getConsoleLevel()
			logger.setConsoleLevel(LOG_NONE)
			self.ui = UIFactory(self.uiType)
			self.ui.drawRootText(1, 1, _('Open PC ServerIntegration'))
			setUI(self.ui)
	
	def exitUi(self):
		if self.ui:
			self.ui.exit()
			logger.setConsoleLevel(self.consoleLevelSaved)
			
	def productPropertiesDialog(self, packageFiles):
		self.initUi()
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for packageFile in packageFiles:
			for p in self.getProductPackageFile(packageFile).product.productProperties:
				defaultValue = p.defaultValue
				if (len(p.possibleValues) > 0):
					values = []
					for v in p.possibleValues:
						values.append( { "name": v, "selected": (v == defaultValue) } )
					defaultValue = self.ui.getSelection(values, radio=True,
									title=_("Please select default value for product property '%s'") % p.name, 
									text=p.description)
					if defaultValue != None:
						defaultValue = defaultValue[0]
				else:
					defaultValue = self.ui.getValue(text=p.description, default=defaultValue)
					
				if (defaultValue != None):
					p.defaultValue = defaultValue
		self.exitUi()
	
	def getProductInformations(self, depotIds):
		logger.debug('Getting product informations')
		info = {}
		for depotId in depotIds:
			info[depotId]= {}
			be = self.getDepotConnection(depotId)
			for productId in be.getProductIds_list(objectId = depotId):
				info[depotId][productId]= be.getProduct_hash(productId = productId, depotId = depotId)
		return info
	
	
	def uploadToRepositories(self, packageFiles, depotIds):
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
			
		for depotId in depotIds:
			tq = TaskQueue(name = "Upload of package(s) %s to repository '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				localFile = self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile)
				
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
		
	def installOnDepots(self, packageFiles, depotIds):
		
		for packageFile in packageFiles:
			self.openProductPackageFile(packageFile)
		
		for depotId in depotIds:
			tq = TaskQueue(name = "Install of package(s) %s on depot '%s'" % (', '.join(packageFiles), depotId))
			for packageFile in packageFiles:
				localFile = self.getLocalDepotPath(depotId) + '/' + os.path.basename(packageFile)
				tq.addTask(
					UploadTask(
						name = "Upload of package '%s' to repository '%s'" % (packageFile, depotId),
						opsiPackageManager = self,
						method = self.uploadToRepository,
						params = (packageFile, depotId)
					)
				)
				tq.addTask(
					InstallTask(
						name = "Install of package '%s' on depot '%s'" % (localFile, depotId),
						opsiPackageManager = self,
						method = self.installPackage,
						params = (localFile, depotId)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
	
	def uninstallOnDepots(self, productIds, depotIds):
		
		for depotId in depotIds:
			tq = TaskQueue(name = "Uninstall of package(s) %s on depot '%s'" % (', '.join(productIds), depotId))
			for productId in productIds:
				tq.addTask(
					UninstallTask(
						name = "Uninstall of package '%s' on depot '%s'" % (productId, depotId),
						opsiPackageManager = self,
						method = self.uninstallPackage,
						params = (productId, depotId)
					)
				)
			self.taskQueues.append(tq)
			logger.info("Starting task queue '%s'" % tq.name)
			tq.start()
		
	def uploadToRepository(self, packageFile, depotId):
		logger.notice("Processing upload of '%s' to depot '%s'" \
				% (os.path.basename(packageFile), depotId))
		if not self.quiet: print _("Processing upload of '%s' to depot '%s'") \
						% (os.path.basename(packageFile), depotId)
		
		packageSize = os.stat(packageFile)[stat.ST_SIZE]
		destination = os.path.basename(packageFile)
		
		repositoryUrl = self.getRepositoryRemoteURL(depotId)
		logger.info("Using '%s' as repository url" % repositoryUrl)
		
		repository = getRepository(repositoryUrl, depotId, self.configBackend.getOpsiHostKey(depotId))
		if destination in repository.content():
			logger.info("Destination '%s' already exists on depot '%s'" % (destination, depotId))
			
			if not self.overwriteAlways:
				if ( repository.fileInfo(destination)['size'] != packageSize ):
					logger.info("Size of source and destination differs on depot '%s'" % depotId)
					if not self.overwriteIfSizeDiffers:
						return
				else:
					logger.info("Size of source and destination matches on depot '%s'" % depotId)
					return
			logger.info("Overwriting destination '%s' on depot '%s'" % (destination, depotId))
			if not self.quiet: print _("Overwriting destination '%s' on depot '%s'") % (destination, depotId)
		
		logger.notice("Starting upload of '%s' to depot '%s'" \
				% (os.path.basename(packageFile), depotId))
		if not self.quiet: print _("Starting upload of '%s' to depot '%s'") \
						% (os.path.basename(packageFile), depotId)
		repository.upload(packageFile, destination, progressListener = self)
		logger.notice("Upload of '%s' to depot '%s' done" \
				% (os.path.basename(packageFile), depotId))
		if not self.quiet: print _("Upload of '%s' to depot '%s' done") \
						% (os.path.basename(packageFile), depotId)
	
	def installPackage(self, packageFile, depotId):
		be = None
		try:
			logger.notice("Installing package '%s' on depot '%s'" \
				% (os.path.basename(packageFile), depotId))
			if not self.quiet: print _("Installing package '%s' on depot '%s'") \
						% (os.path.basename(packageFile), depotId)
			productId = self.getProductPackageFile(packageFile).product.productId
			
			be = self.getDepotConnection(depotId)
			
			defaultProperties = {}
			if self.keepDefaultProductProperties:
				try:
					for pd in be.getProductPropertyDefinitions_listOfHashes(productId, depotId):
						defaultProperties[pd['name']] = pd['default']
				except Exception, e:
					logger.warning(e)
			
			be.installPackage(packageFile, force = self.forceInstall, defaultProperties = defaultProperties)
			be.exit()
			logger.notice("Installation of package '%s' on depot '%s' finished" % (packageFile, depotId))
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			raise
		
	def uninstallPackage(self, productId, depotId):
		be = None
		try:
			logger.notice("Uninstalling package '%s' on depot '%s'" % (productId, depotId))
			if not self.quiet: print _("Uninstalling package '%s' on depot '%s'") \
						% (productId, depotId)
			
			repositoryUrl = self.getRepositoryRemoteURL(depotId)
			logger.info("Using '%s' as repository url" % repositoryUrl)
			repository = getRepository(repositoryUrl, depotId, self.configBackend.getOpsiHostKey(depotId))
			for destination in repository.content():
				if not destination.startswith(productId + '_'):
					continue
				logger.info("Deleting destination '%s' on depot '%s'" % (destination, depotId))
				repository.delete(destination)
			
			be = self.getDepotConnection(depotId)
			be.uninstallPackage(productId, force = self.forceUninstall, deleteFiles = self.deleteFilesOnUninstall)
			be.exit()
			logger.notice("Uninstall of package '%s' on depot '%s' finished" % (productId, depotId))
		except Exception, e:
			logger.error(e)
			if be: be.exit()
			raise
		
	def progressChanged(self, progress):
		
		minutesLeft = str(int(progress.timeLeft/60))
		secondsLeft = str(int(progress.timeLeft%60))
		if (len(minutesLeft) < 2): minutesLeft = '0' + minutesLeft
		if (len(secondsLeft) < 2): secondsLeft = '0' + secondsLeft
		msg =   '   %8s' % ("%.2f" % progress.percent + '% ') \
			+ '%8s KB' % (progress.state/1024) \
			+ '%8s KB/s' % (int(progress.bytesPerSecond/1024)) \
			+ '%4s:%s ETAs' % (minutesLeft, secondsLeft) \
			+ ' - %s' % progress.name
		logger.info(msg)
		if not self.quiet: print msg



def printHelp():
	print \
	'''
Usage: %s [options]

Manage opsi packages

Commands:
  -i, --install     <opsi-package> ...      install opsi packages
  -u, --upload      <opsi-package> ...      upload opsi packages to repositories
  -l, --list        <regex>                 list opsi packages
  -r, --remove      <opsi-product-id>       uninstall opsi packages
  -V, --version                             show program's version info and exit
  -h, --help                                show this help message and exit

Options:
  -d, --depots      <depots>                comma seperated list of depots to process
                                                (default: %s)
                                                use keyword ALL to process all known depots
  --max-transfers   <num>                   maximum number of simultaneous uploads
                                                 0=unlimited (default)
  -f, --force                               force install/uninstall (use with extreme caution)
  -k, --keep-files                          do not delete client data dir on uninstall
  -o, --overwrite                           overwrite existing package even if size matches
  -p, --properties  <mode>                  mode for default product property values
                      ask                      display dialog
                      package                  use defaults from package (default)
                      keep                     keep depot defaults
  --interface       <type>                  type of user interface
                      text                      text based interface
                      snack                     newt interface (default)
  -v, --verbose                             increase verbosity (can be used multiple times)
  -q, --quiet                               do not display any messages
  --log-file        <log-file>              path to debug log file
	''' % (os.path.basename(sys.argv[0]), socket.getfqdn())

def printVersion():
	print "%s %s" % (os.path.basename(sys.argv[0]), __version__)

def main(argv):
	os.umask(0027)
	
	global logLevel
	
	parser=OptionParser( add_help_option = False )
	
	parser.add_option("-h", "--help",           action="store_true", dest="help")
	parser.add_option("-V", "--version",        action="store_true", dest="version")
	parser.add_option("-v", "--verbose",        action="count",      dest="verbose")
	parser.add_option("-q", "--quiet",          action="store_true", dest="quiet")
	parser.add_option("-i", "--install",        action="store_true", dest="COMMAND_INSTALL")
	parser.add_option("-u", "--upload",         action="store_true", dest="COMMAND_UPLOAD")
	parser.add_option("-p", "--properties",     action="store",      dest="properties",   default="package", choices=['ask', 'package', 'keep'])
	parser.add_option(      "--max-transfers",  action="store",      dest="maxTransfers", default = 0,       type="int")
	parser.add_option("-l", "--list",           action="store_true", dest="COMMAND_LIST")
	parser.add_option("-r", "--remove",         action="store_true", dest="COMMAND_REMOVE")
	parser.add_option("-d", "--depots",         action="store",      dest="depots")
	parser.add_option("-f", "--force",          action="store_true", dest="force")
	parser.add_option("-k", "--keep-files",     action="store_true", dest="keepFiles")
	parser.add_option("-o", "--overwrite",      action="store_true", dest="overwriteAlways")
	parser.add_option(      "--interface",      action="store",      dest="interface",    default="snack",   choices=['text', 'snack'])
	parser.add_option(      "--log-file",       action="store",      dest="logFile")
	
	(options, args) = parser.parse_args()
	
	if options.help:
		printHelp()
		sys.exit(0)
	
	if options.version:
		printVersion()
		sys.exit(0)
	
	if options.logFile:
		if os.path.exists(options.logFile):
			os.unlink(options.logFile)
		logger.setLogFile(options.logFile)
		logger.setFileLevel(LOG_DEBUG2)
	
	if (options.properties == 'ask') and options.quiet:
		print >> sys.stderr, _("You cannot use properties=ask in quiet mode")
		sys.exit(1)
	
	if options.quiet:
		options.interface = 'dummy'
		logLevel = LOG_NONE
	elif options.verbose:
		logLevel = LOG_WARNING
		logLevel += options.verbose
		
	logger.setConsoleLevel(logLevel)
	
	cmds = 0
	for cmd in (options.COMMAND_INSTALL, options.COMMAND_UPLOAD, options.COMMAND_LIST, options.COMMAND_REMOVE):
		if not cmd:
			continue
		cmds += 1
	if (cmds > 1):
		print >> sys.stderr, _("More than one command specified")
		sys.exit(1)
	elif (cmds < 1):
		print >> sys.stderr, _("No command specified")
		sys.exit(1)
	
	packageFiles = []
	productRegex = re.compile('.*')
	productIds = []
	if options.COMMAND_INSTALL or options.COMMAND_UPLOAD:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi package given!")
			sys.exit(1)
		
		for p in args:
			p = os.path.abspath(p)
			if not os.path.exists(p):
				print >> sys.stderr, _("Package file '%s' does not exist!") % p
				sys.exit(1)
			packageFiles.append(p)
		
	elif options.COMMAND_LIST:
		if args:
			if (len(args) > 1):
				printHelp()
				sys.exit(1)
			productRegex = re.compile(args[0])
	
	elif options.COMMAND_REMOVE:
		if (len(args) < 1):
			print >> sys.stderr, _("No opsi product id given!")
			sys.exit(1)
		productIds = args
	
	
	bm = BackendManager(authRequired=False)
	opm = None
	try:
		opm = OpsiPackageManager(bm)
		
		opm.forceInstall = opm.forceUninstall = options.force
		opm.uiType = options.interface
		opm.quiet = options.quiet
		opm.maxTransfers = options.maxTransfers
		opm.deleteFilesOnUninstall = not options.keepFiles
		opm.overwriteAlways = options.overwriteAlways
		
		depotIds = [ socket.getfqdn() ]
		if options.depots:
			if (options.depots.lower() == 'all'):
				depotIds = bm.getDepotIds_list()
			else:
				depotIds = options.depots.lower().split(',')
				knownDepotIds = bm.getDepotIds_list()
				for depotId in depotIds:
					if depotId not in knownDepotIds:
						raise Exception("Depot '%s' not in list of known depots: %s" \
							% (depotId, ', '.join(knownDepotIds)))
		
		if options.COMMAND_INSTALL:
			if (options.properties == 'ask'):
				opm.productPropertiesDialog(packageFiles)
			elif (options.properties == 'depot'):
				opm.keepDefaultProductProperties = True
			else:
				opm.keepDefaultProductProperties = False
			opm.installOnDepots(packageFiles, depotIds)
		
		elif options.COMMAND_UPLOAD:
			opm.uploadToRepositories(packageFiles, depotIds)
		
		elif options.COMMAND_REMOVE:
			opm.uninstallOnDepots(productIds, depotIds)
			
		elif options.COMMAND_LIST:
			terminalWidth = 60
			try:
				tty = os.popen('tty').readline().strip()
				fd = open(tty)
				terminalWidth = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))[1]
				fd.close()
			except:
				pass
			indent = "   "
			idWidth = versionWidth = int((terminalWidth-len(indent))/3)
			if (idWidth > 25): idWidth = 25
			if (versionWidth > 25): versionWidth = 25
			descriptionWidth = terminalWidth-len(indent)-idWidth-versionWidth-4
			
			for (depotId, productInfo) in opm.getProductInformations(depotIds).items():
				print "-"*(len(depotId)+4)
				print "- %s -" % depotId
				print "-"*(len(depotId)+4)
				print "%s%*s %*s %*s" % (indent, -1*idWidth, _('Product ID'),
							-1*versionWidth, _('Version'),
							-1*descriptionWidth, _('Description'))
				print "%s%s" % (indent, "="*(terminalWidth-len(indent)-2))
				for (productId, product) in productInfo.items():
					if not re.search(productRegex, productId):
						continue
					print "%s%*s %*s %*s" % (indent, -1*idWidth, productId,
							-1*versionWidth, product.get('productVersion', '') + '-' + product.get('packageVersion', ''),
							-1*descriptionWidth, product.get('description', '').replace('\n', '')[:descriptionWidth])
				print ""
		
	except Exception, e:
		if opm:	opm.exitUi()
		raise
	
	while(threading.activeCount() > 1):
		time.sleep(1)
	
	errors = opm.getErrors()
	if errors:
		print >> sys.stderr, _("ERRORS OCCURED: ")
		for (name, errs) in errors.items():
			logger.error("Failure while processing: %s" % name)
			print >> sys.stderr, "Failure while processing: %s" % name
			for err in errs:
				logger.error("   %s" % err)
				print >> sys.stderr, "   %s" % err
		sys.exit(1)

	
	
if (__name__ == "__main__"):
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		sys.exit(int(str(e)))
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, _("ERROR: ") + str(exception)
		sys.exit(1)
	
	sys.exit(0)



